#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def ping(self):
        pass

    def getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def getMarginalDrivingFeaturesBinary(self, session, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
        """
        pass

    def getDrivingFeaturesEpsilonMOEABinary(self, session, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def getMarginalDrivingFeaturesDiscrete(self, session, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
        """
        pass

    def getDrivingFeaturesEpsilonMOEADiscrete(self, session, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def getDrivingFeaturesContinuous(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def getDrivingFeaturesEpsilonMOEAContinuous(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def generalizeFeatureBinary(self, session, problem, behavioral, non_behavioral, all_archs, rootfeatureExpression, nodeFeatureExpression):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - rootfeatureExpression
         - nodeFeatureExpression
        """
        pass

    def getDrivingFeaturesWithGeneralizationBinary(self, session, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def simplifyFeatureExpression(self, session, problem, expression):
        """
        Parameters:
         - session
         - problem
         - expression
        """
        pass

    def stopSearch(self, session):
        """
        Parameters:
         - session
        """
        pass

    def computeComplexityOfFeatures(self, expressions):
        """
        Parameters:
         - expressions
        """
        pass

    def computeAlgebraicTypicality(self, problem, arch, feature):
        """
        Parameters:
         - problem
         - arch
         - feature
        """
        pass

    def computeComplexity(self, expression):
        """
        Parameters:
         - expression
        """
        pass

    def convertToCNF(self, expression):
        """
        Parameters:
         - expression
        """
        pass

    def convertToDNF(self, expression):
        """
        Parameters:
         - expression
        """
        pass

    def setAssigningProblemEntities(self, session, problem, entities):
        """
        Parameters:
         - session
         - problem
         - entities
        """
        pass

    def setAssigningProblemGeneralizedConcepts(self, session, problem, generalizedConcepts):
        """
        Parameters:
         - session
         - problem
         - generalizedConcepts
        """
        pass

    def getAssigningProblemEntities(self, session, problem):
        """
        Parameters:
         - session
         - problem
        """
        pass

    def getAssigningProblemConceptHierarchy(self, session, problem, params):
        """
        Parameters:
         - session
         - problem
         - params
        """
        pass

    def computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        """
        Parameters:
         - problem
         - architecture
         - feature
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def ping(self):
        self.send_ping()
        self.recv_ping()

    def send_ping(self):
        self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
        args = ping_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_getDrivingFeaturesBinary(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_getDrivingFeaturesBinary()

    def send_getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('getDrivingFeaturesBinary', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesBinary failed: unknown result")

    def getMarginalDrivingFeaturesBinary(self, session, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
        """
        self.send_getMarginalDrivingFeaturesBinary(session, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective)
        return self.recv_getMarginalDrivingFeaturesBinary()

    def send_getMarginalDrivingFeaturesBinary(self, session, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective):
        self._oprot.writeMessageBegin('getMarginalDrivingFeaturesBinary', TMessageType.CALL, self._seqid)
        args = getMarginalDrivingFeaturesBinary_args()
        args.session = session
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.featureExpression = featureExpression
        args.logical_connective = logical_connective
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMarginalDrivingFeaturesBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMarginalDrivingFeaturesBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMarginalDrivingFeaturesBinary failed: unknown result")

    def getDrivingFeaturesEpsilonMOEABinary(self, session, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesEpsilonMOEABinary(session, problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesEpsilonMOEABinary()

    def send_getDrivingFeaturesEpsilonMOEABinary(self, session, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesEpsilonMOEABinary', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesEpsilonMOEABinary_args()
        args.session = session
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesEpsilonMOEABinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesEpsilonMOEABinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesEpsilonMOEABinary failed: unknown result")

    def getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_getDrivingFeaturesDiscrete(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_getDrivingFeaturesDiscrete()

    def send_getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('getDrivingFeaturesDiscrete', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesDiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesDiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesDiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesDiscrete failed: unknown result")

    def getMarginalDrivingFeaturesDiscrete(self, session, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
        """
        self.send_getMarginalDrivingFeaturesDiscrete(session, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective)
        return self.recv_getMarginalDrivingFeaturesDiscrete()

    def send_getMarginalDrivingFeaturesDiscrete(self, session, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective):
        self._oprot.writeMessageBegin('getMarginalDrivingFeaturesDiscrete', TMessageType.CALL, self._seqid)
        args = getMarginalDrivingFeaturesDiscrete_args()
        args.session = session
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.featureExpression = featureExpression
        args.logical_connective = logical_connective
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMarginalDrivingFeaturesDiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMarginalDrivingFeaturesDiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMarginalDrivingFeaturesDiscrete failed: unknown result")

    def getDrivingFeaturesEpsilonMOEADiscrete(self, session, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesEpsilonMOEADiscrete(session, problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesEpsilonMOEADiscrete()

    def send_getDrivingFeaturesEpsilonMOEADiscrete(self, session, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesEpsilonMOEADiscrete', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesEpsilonMOEADiscrete_args()
        args.session = session
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesEpsilonMOEADiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesEpsilonMOEADiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesEpsilonMOEADiscrete failed: unknown result")

    def getDrivingFeaturesContinuous(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_getDrivingFeaturesContinuous(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_getDrivingFeaturesContinuous()

    def send_getDrivingFeaturesContinuous(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('getDrivingFeaturesContinuous', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesContinuous_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesContinuous(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesContinuous_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesContinuous failed: unknown result")

    def getDrivingFeaturesEpsilonMOEAContinuous(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesEpsilonMOEAContinuous(problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesEpsilonMOEAContinuous()

    def send_getDrivingFeaturesEpsilonMOEAContinuous(self, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesEpsilonMOEAContinuous', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesEpsilonMOEAContinuous_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesEpsilonMOEAContinuous(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesEpsilonMOEAContinuous_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesEpsilonMOEAContinuous failed: unknown result")

    def generalizeFeatureBinary(self, session, problem, behavioral, non_behavioral, all_archs, rootfeatureExpression, nodeFeatureExpression):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - rootfeatureExpression
         - nodeFeatureExpression
        """
        self.send_generalizeFeatureBinary(session, problem, behavioral, non_behavioral, all_archs, rootfeatureExpression, nodeFeatureExpression)
        return self.recv_generalizeFeatureBinary()

    def send_generalizeFeatureBinary(self, session, problem, behavioral, non_behavioral, all_archs, rootfeatureExpression, nodeFeatureExpression):
        self._oprot.writeMessageBegin('generalizeFeatureBinary', TMessageType.CALL, self._seqid)
        args = generalizeFeatureBinary_args()
        args.session = session
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.rootfeatureExpression = rootfeatureExpression
        args.nodeFeatureExpression = nodeFeatureExpression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_generalizeFeatureBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = generalizeFeatureBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "generalizeFeatureBinary failed: unknown result")

    def getDrivingFeaturesWithGeneralizationBinary(self, session, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - session
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesWithGeneralizationBinary(session, problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesWithGeneralizationBinary()

    def send_getDrivingFeaturesWithGeneralizationBinary(self, session, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesWithGeneralizationBinary', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesWithGeneralizationBinary_args()
        args.session = session
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesWithGeneralizationBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesWithGeneralizationBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesWithGeneralizationBinary failed: unknown result")

    def simplifyFeatureExpression(self, session, problem, expression):
        """
        Parameters:
         - session
         - problem
         - expression
        """
        self.send_simplifyFeatureExpression(session, problem, expression)
        return self.recv_simplifyFeatureExpression()

    def send_simplifyFeatureExpression(self, session, problem, expression):
        self._oprot.writeMessageBegin('simplifyFeatureExpression', TMessageType.CALL, self._seqid)
        args = simplifyFeatureExpression_args()
        args.session = session
        args.problem = problem
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_simplifyFeatureExpression(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = simplifyFeatureExpression_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "simplifyFeatureExpression failed: unknown result")

    def stopSearch(self, session):
        """
        Parameters:
         - session
        """
        self.send_stopSearch(session)
        return self.recv_stopSearch()

    def send_stopSearch(self, session):
        self._oprot.writeMessageBegin('stopSearch', TMessageType.CALL, self._seqid)
        args = stopSearch_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stopSearch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stopSearch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stopSearch failed: unknown result")

    def computeComplexityOfFeatures(self, expressions):
        """
        Parameters:
         - expressions
        """
        self.send_computeComplexityOfFeatures(expressions)
        return self.recv_computeComplexityOfFeatures()

    def send_computeComplexityOfFeatures(self, expressions):
        self._oprot.writeMessageBegin('computeComplexityOfFeatures', TMessageType.CALL, self._seqid)
        args = computeComplexityOfFeatures_args()
        args.expressions = expressions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeComplexityOfFeatures(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeComplexityOfFeatures_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeComplexityOfFeatures failed: unknown result")

    def computeAlgebraicTypicality(self, problem, arch, feature):
        """
        Parameters:
         - problem
         - arch
         - feature
        """
        self.send_computeAlgebraicTypicality(problem, arch, feature)
        return self.recv_computeAlgebraicTypicality()

    def send_computeAlgebraicTypicality(self, problem, arch, feature):
        self._oprot.writeMessageBegin('computeAlgebraicTypicality', TMessageType.CALL, self._seqid)
        args = computeAlgebraicTypicality_args()
        args.problem = problem
        args.arch = arch
        args.feature = feature
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeAlgebraicTypicality(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeAlgebraicTypicality_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeAlgebraicTypicality failed: unknown result")

    def computeComplexity(self, expression):
        """
        Parameters:
         - expression
        """
        self.send_computeComplexity(expression)
        return self.recv_computeComplexity()

    def send_computeComplexity(self, expression):
        self._oprot.writeMessageBegin('computeComplexity', TMessageType.CALL, self._seqid)
        args = computeComplexity_args()
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeComplexity(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeComplexity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeComplexity failed: unknown result")

    def convertToCNF(self, expression):
        """
        Parameters:
         - expression
        """
        self.send_convertToCNF(expression)
        return self.recv_convertToCNF()

    def send_convertToCNF(self, expression):
        self._oprot.writeMessageBegin('convertToCNF', TMessageType.CALL, self._seqid)
        args = convertToCNF_args()
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_convertToCNF(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = convertToCNF_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "convertToCNF failed: unknown result")

    def convertToDNF(self, expression):
        """
        Parameters:
         - expression
        """
        self.send_convertToDNF(expression)
        return self.recv_convertToDNF()

    def send_convertToDNF(self, expression):
        self._oprot.writeMessageBegin('convertToDNF', TMessageType.CALL, self._seqid)
        args = convertToDNF_args()
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_convertToDNF(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = convertToDNF_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "convertToDNF failed: unknown result")

    def setAssigningProblemEntities(self, session, problem, entities):
        """
        Parameters:
         - session
         - problem
         - entities
        """
        self.send_setAssigningProblemEntities(session, problem, entities)
        return self.recv_setAssigningProblemEntities()

    def send_setAssigningProblemEntities(self, session, problem, entities):
        self._oprot.writeMessageBegin('setAssigningProblemEntities', TMessageType.CALL, self._seqid)
        args = setAssigningProblemEntities_args()
        args.session = session
        args.problem = problem
        args.entities = entities
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setAssigningProblemEntities(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setAssigningProblemEntities_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setAssigningProblemEntities failed: unknown result")

    def setAssigningProblemGeneralizedConcepts(self, session, problem, generalizedConcepts):
        """
        Parameters:
         - session
         - problem
         - generalizedConcepts
        """
        self.send_setAssigningProblemGeneralizedConcepts(session, problem, generalizedConcepts)
        return self.recv_setAssigningProblemGeneralizedConcepts()

    def send_setAssigningProblemGeneralizedConcepts(self, session, problem, generalizedConcepts):
        self._oprot.writeMessageBegin('setAssigningProblemGeneralizedConcepts', TMessageType.CALL, self._seqid)
        args = setAssigningProblemGeneralizedConcepts_args()
        args.session = session
        args.problem = problem
        args.generalizedConcepts = generalizedConcepts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setAssigningProblemGeneralizedConcepts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setAssigningProblemGeneralizedConcepts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setAssigningProblemGeneralizedConcepts failed: unknown result")

    def getAssigningProblemEntities(self, session, problem):
        """
        Parameters:
         - session
         - problem
        """
        self.send_getAssigningProblemEntities(session, problem)
        return self.recv_getAssigningProblemEntities()

    def send_getAssigningProblemEntities(self, session, problem):
        self._oprot.writeMessageBegin('getAssigningProblemEntities', TMessageType.CALL, self._seqid)
        args = getAssigningProblemEntities_args()
        args.session = session
        args.problem = problem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAssigningProblemEntities(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAssigningProblemEntities_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAssigningProblemEntities failed: unknown result")

    def getAssigningProblemConceptHierarchy(self, session, problem, params):
        """
        Parameters:
         - session
         - problem
         - params
        """
        self.send_getAssigningProblemConceptHierarchy(session, problem, params)
        return self.recv_getAssigningProblemConceptHierarchy()

    def send_getAssigningProblemConceptHierarchy(self, session, problem, params):
        self._oprot.writeMessageBegin('getAssigningProblemConceptHierarchy', TMessageType.CALL, self._seqid)
        args = getAssigningProblemConceptHierarchy_args()
        args.session = session
        args.problem = problem
        args.params = params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAssigningProblemConceptHierarchy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAssigningProblemConceptHierarchy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAssigningProblemConceptHierarchy failed: unknown result")

    def computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        """
        Parameters:
         - problem
         - architecture
         - feature
        """
        self.send_computeAlgebraicTypicalityWithStringInput(problem, architecture, feature)
        return self.recv_computeAlgebraicTypicalityWithStringInput()

    def send_computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        self._oprot.writeMessageBegin('computeAlgebraicTypicalityWithStringInput', TMessageType.CALL, self._seqid)
        args = computeAlgebraicTypicalityWithStringInput_args()
        args.problem = problem
        args.architecture = architecture
        args.feature = feature
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeAlgebraicTypicalityWithStringInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeAlgebraicTypicalityWithStringInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeAlgebraicTypicalityWithStringInput failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["ping"] = Processor.process_ping
        self._processMap["getDrivingFeaturesBinary"] = Processor.process_getDrivingFeaturesBinary
        self._processMap["getMarginalDrivingFeaturesBinary"] = Processor.process_getMarginalDrivingFeaturesBinary
        self._processMap["getDrivingFeaturesEpsilonMOEABinary"] = Processor.process_getDrivingFeaturesEpsilonMOEABinary
        self._processMap["getDrivingFeaturesDiscrete"] = Processor.process_getDrivingFeaturesDiscrete
        self._processMap["getMarginalDrivingFeaturesDiscrete"] = Processor.process_getMarginalDrivingFeaturesDiscrete
        self._processMap["getDrivingFeaturesEpsilonMOEADiscrete"] = Processor.process_getDrivingFeaturesEpsilonMOEADiscrete
        self._processMap["getDrivingFeaturesContinuous"] = Processor.process_getDrivingFeaturesContinuous
        self._processMap["getDrivingFeaturesEpsilonMOEAContinuous"] = Processor.process_getDrivingFeaturesEpsilonMOEAContinuous
        self._processMap["generalizeFeatureBinary"] = Processor.process_generalizeFeatureBinary
        self._processMap["getDrivingFeaturesWithGeneralizationBinary"] = Processor.process_getDrivingFeaturesWithGeneralizationBinary
        self._processMap["simplifyFeatureExpression"] = Processor.process_simplifyFeatureExpression
        self._processMap["stopSearch"] = Processor.process_stopSearch
        self._processMap["computeComplexityOfFeatures"] = Processor.process_computeComplexityOfFeatures
        self._processMap["computeAlgebraicTypicality"] = Processor.process_computeAlgebraicTypicality
        self._processMap["computeComplexity"] = Processor.process_computeComplexity
        self._processMap["convertToCNF"] = Processor.process_convertToCNF
        self._processMap["convertToDNF"] = Processor.process_convertToDNF
        self._processMap["setAssigningProblemEntities"] = Processor.process_setAssigningProblemEntities
        self._processMap["setAssigningProblemGeneralizedConcepts"] = Processor.process_setAssigningProblemGeneralizedConcepts
        self._processMap["getAssigningProblemEntities"] = Processor.process_getAssigningProblemEntities
        self._processMap["getAssigningProblemConceptHierarchy"] = Processor.process_getAssigningProblemConceptHierarchy
        self._processMap["computeAlgebraicTypicalityWithStringInput"] = Processor.process_computeAlgebraicTypicalityWithStringInput

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_ping(self, seqid, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        try:
            self._handler.ping()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesBinary(self, seqid, iprot, oprot):
        args = getDrivingFeaturesBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesBinary_result()
        try:
            result.success = self._handler.getDrivingFeaturesBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMarginalDrivingFeaturesBinary(self, seqid, iprot, oprot):
        args = getMarginalDrivingFeaturesBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMarginalDrivingFeaturesBinary_result()
        try:
            result.success = self._handler.getMarginalDrivingFeaturesBinary(args.session, args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.featureExpression, args.logical_connective)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMarginalDrivingFeaturesBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesEpsilonMOEABinary(self, seqid, iprot, oprot):
        args = getDrivingFeaturesEpsilonMOEABinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesEpsilonMOEABinary_result()
        try:
            result.success = self._handler.getDrivingFeaturesEpsilonMOEABinary(args.session, args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesEpsilonMOEABinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesDiscrete(self, seqid, iprot, oprot):
        args = getDrivingFeaturesDiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesDiscrete_result()
        try:
            result.success = self._handler.getDrivingFeaturesDiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesDiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMarginalDrivingFeaturesDiscrete(self, seqid, iprot, oprot):
        args = getMarginalDrivingFeaturesDiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMarginalDrivingFeaturesDiscrete_result()
        try:
            result.success = self._handler.getMarginalDrivingFeaturesDiscrete(args.session, args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.featureExpression, args.logical_connective)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMarginalDrivingFeaturesDiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesEpsilonMOEADiscrete(self, seqid, iprot, oprot):
        args = getDrivingFeaturesEpsilonMOEADiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesEpsilonMOEADiscrete_result()
        try:
            result.success = self._handler.getDrivingFeaturesEpsilonMOEADiscrete(args.session, args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesEpsilonMOEADiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesContinuous(self, seqid, iprot, oprot):
        args = getDrivingFeaturesContinuous_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesContinuous_result()
        try:
            result.success = self._handler.getDrivingFeaturesContinuous(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesContinuous", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesEpsilonMOEAContinuous(self, seqid, iprot, oprot):
        args = getDrivingFeaturesEpsilonMOEAContinuous_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesEpsilonMOEAContinuous_result()
        try:
            result.success = self._handler.getDrivingFeaturesEpsilonMOEAContinuous(args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesEpsilonMOEAContinuous", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_generalizeFeatureBinary(self, seqid, iprot, oprot):
        args = generalizeFeatureBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = generalizeFeatureBinary_result()
        try:
            result.success = self._handler.generalizeFeatureBinary(args.session, args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.rootfeatureExpression, args.nodeFeatureExpression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("generalizeFeatureBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesWithGeneralizationBinary(self, seqid, iprot, oprot):
        args = getDrivingFeaturesWithGeneralizationBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesWithGeneralizationBinary_result()
        try:
            result.success = self._handler.getDrivingFeaturesWithGeneralizationBinary(args.session, args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesWithGeneralizationBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_simplifyFeatureExpression(self, seqid, iprot, oprot):
        args = simplifyFeatureExpression_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = simplifyFeatureExpression_result()
        try:
            result.success = self._handler.simplifyFeatureExpression(args.session, args.problem, args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("simplifyFeatureExpression", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stopSearch(self, seqid, iprot, oprot):
        args = stopSearch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stopSearch_result()
        try:
            result.success = self._handler.stopSearch(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stopSearch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeComplexityOfFeatures(self, seqid, iprot, oprot):
        args = computeComplexityOfFeatures_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeComplexityOfFeatures_result()
        try:
            result.success = self._handler.computeComplexityOfFeatures(args.expressions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeComplexityOfFeatures", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeAlgebraicTypicality(self, seqid, iprot, oprot):
        args = computeAlgebraicTypicality_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeAlgebraicTypicality_result()
        try:
            result.success = self._handler.computeAlgebraicTypicality(args.problem, args.arch, args.feature)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeAlgebraicTypicality", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeComplexity(self, seqid, iprot, oprot):
        args = computeComplexity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeComplexity_result()
        try:
            result.success = self._handler.computeComplexity(args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeComplexity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_convertToCNF(self, seqid, iprot, oprot):
        args = convertToCNF_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = convertToCNF_result()
        try:
            result.success = self._handler.convertToCNF(args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("convertToCNF", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_convertToDNF(self, seqid, iprot, oprot):
        args = convertToDNF_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = convertToDNF_result()
        try:
            result.success = self._handler.convertToDNF(args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("convertToDNF", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setAssigningProblemEntities(self, seqid, iprot, oprot):
        args = setAssigningProblemEntities_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setAssigningProblemEntities_result()
        try:
            result.success = self._handler.setAssigningProblemEntities(args.session, args.problem, args.entities)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setAssigningProblemEntities", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setAssigningProblemGeneralizedConcepts(self, seqid, iprot, oprot):
        args = setAssigningProblemGeneralizedConcepts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setAssigningProblemGeneralizedConcepts_result()
        try:
            result.success = self._handler.setAssigningProblemGeneralizedConcepts(args.session, args.problem, args.generalizedConcepts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setAssigningProblemGeneralizedConcepts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAssigningProblemEntities(self, seqid, iprot, oprot):
        args = getAssigningProblemEntities_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAssigningProblemEntities_result()
        try:
            result.success = self._handler.getAssigningProblemEntities(args.session, args.problem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAssigningProblemEntities", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAssigningProblemConceptHierarchy(self, seqid, iprot, oprot):
        args = getAssigningProblemConceptHierarchy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAssigningProblemConceptHierarchy_result()
        try:
            result.success = self._handler.getAssigningProblemConceptHierarchy(args.session, args.problem, args.params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAssigningProblemConceptHierarchy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeAlgebraicTypicalityWithStringInput(self, seqid, iprot, oprot):
        args = computeAlgebraicTypicalityWithStringInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeAlgebraicTypicalityWithStringInput_result()
        try:
            result.success = self._handler.computeAlgebraicTypicalityWithStringInput(args.problem, args.architecture, args.feature)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeAlgebraicTypicalityWithStringInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class ping_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_args)
ping_args.thrift_spec = (
)


class ping_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_result)
ping_result.thrift_spec = (
)


class getDrivingFeaturesBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype112, _size109) = iprot.readListBegin()
                    for _i113 in range(_size109):
                        _elem114 = iprot.readI32()
                        self.behavioral.append(_elem114)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype118, _size115) = iprot.readListBegin()
                    for _i119 in range(_size115):
                        _elem120 = iprot.readI32()
                        self.non_behavioral.append(_elem120)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = BinaryInputArchitecture()
                        _elem126.read(iprot)
                        self.all_archs.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter127 in self.behavioral:
                oprot.writeI32(iter127)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter128 in self.non_behavioral:
                oprot.writeI32(iter128)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter129 in self.all_archs:
                iter129.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesBinary_args)
getDrivingFeaturesBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class getDrivingFeaturesBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype133, _size130) = iprot.readListBegin()
                    for _i134 in range(_size130):
                        _elem135 = Feature()
                        _elem135.read(iprot)
                        self.success.append(_elem135)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter136 in self.success:
                iter136.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesBinary_result)
getDrivingFeaturesBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getMarginalDrivingFeaturesBinary_args(object):
    """
    Attributes:
     - session
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - featureExpression
     - logical_connective
    """


    def __init__(self, session=None, problem=None, behavioral=None, non_behavioral=None, all_archs=None, featureExpression=None, logical_connective=None,):
        self.session = session
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.featureExpression = featureExpression
        self.logical_connective = logical_connective

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype140, _size137) = iprot.readListBegin()
                    for _i141 in range(_size137):
                        _elem142 = iprot.readI32()
                        self.behavioral.append(_elem142)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype146, _size143) = iprot.readListBegin()
                    for _i147 in range(_size143):
                        _elem148 = iprot.readI32()
                        self.non_behavioral.append(_elem148)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype152, _size149) = iprot.readListBegin()
                    for _i153 in range(_size149):
                        _elem154 = BinaryInputArchitecture()
                        _elem154.read(iprot)
                        self.all_archs.append(_elem154)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.featureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.logical_connective = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesBinary_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 2)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter155 in self.behavioral:
                oprot.writeI32(iter155)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter156 in self.non_behavioral:
                oprot.writeI32(iter156)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter157 in self.all_archs:
                iter157.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.featureExpression is not None:
            oprot.writeFieldBegin('featureExpression', TType.STRING, 6)
            oprot.writeString(self.featureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.featureExpression)
            oprot.writeFieldEnd()
        if self.logical_connective is not None:
            oprot.writeFieldBegin('logical_connective', TType.STRING, 7)
            oprot.writeString(self.logical_connective.encode('utf-8') if sys.version_info[0] == 2 else self.logical_connective)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesBinary_args)
getMarginalDrivingFeaturesBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'problem', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 5
    (6, TType.STRING, 'featureExpression', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'logical_connective', 'UTF8', None, ),  # 7
)


class getMarginalDrivingFeaturesBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesBinary_result)
getMarginalDrivingFeaturesBinary_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class getDrivingFeaturesEpsilonMOEABinary_args(object):
    """
    Attributes:
     - session
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, session=None, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.session = session
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype161, _size158) = iprot.readListBegin()
                    for _i162 in range(_size158):
                        _elem163 = iprot.readI32()
                        self.behavioral.append(_elem163)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype167, _size164) = iprot.readListBegin()
                    for _i168 in range(_size164):
                        _elem169 = iprot.readI32()
                        self.non_behavioral.append(_elem169)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype173, _size170) = iprot.readListBegin()
                    for _i174 in range(_size170):
                        _elem175 = BinaryInputArchitecture()
                        _elem175.read(iprot)
                        self.all_archs.append(_elem175)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEABinary_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 2)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter176 in self.behavioral:
                oprot.writeI32(iter176)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter177 in self.non_behavioral:
                oprot.writeI32(iter177)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter178 in self.all_archs:
                iter178.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEABinary_args)
getDrivingFeaturesEpsilonMOEABinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'problem', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 5
)


class getDrivingFeaturesEpsilonMOEABinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype182, _size179) = iprot.readListBegin()
                    for _i183 in range(_size179):
                        _elem184 = Feature()
                        _elem184.read(iprot)
                        self.success.append(_elem184)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEABinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter185 in self.success:
                iter185.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEABinary_result)
getDrivingFeaturesEpsilonMOEABinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesDiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype189, _size186) = iprot.readListBegin()
                    for _i190 in range(_size186):
                        _elem191 = iprot.readI32()
                        self.behavioral.append(_elem191)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype195, _size192) = iprot.readListBegin()
                    for _i196 in range(_size192):
                        _elem197 = iprot.readI32()
                        self.non_behavioral.append(_elem197)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype201, _size198) = iprot.readListBegin()
                    for _i202 in range(_size198):
                        _elem203 = DiscreteInputArchitecture()
                        _elem203.read(iprot)
                        self.all_archs.append(_elem203)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesDiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter204 in self.behavioral:
                oprot.writeI32(iter204)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter205 in self.non_behavioral:
                oprot.writeI32(iter205)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter206 in self.all_archs:
                iter206.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesDiscrete_args)
getDrivingFeaturesDiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class getDrivingFeaturesDiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype210, _size207) = iprot.readListBegin()
                    for _i211 in range(_size207):
                        _elem212 = Feature()
                        _elem212.read(iprot)
                        self.success.append(_elem212)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesDiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter213 in self.success:
                iter213.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesDiscrete_result)
getDrivingFeaturesDiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getMarginalDrivingFeaturesDiscrete_args(object):
    """
    Attributes:
     - session
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - featureExpression
     - logical_connective
    """


    def __init__(self, session=None, problem=None, behavioral=None, non_behavioral=None, all_archs=None, featureExpression=None, logical_connective=None,):
        self.session = session
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.featureExpression = featureExpression
        self.logical_connective = logical_connective

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype217, _size214) = iprot.readListBegin()
                    for _i218 in range(_size214):
                        _elem219 = iprot.readI32()
                        self.behavioral.append(_elem219)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype223, _size220) = iprot.readListBegin()
                    for _i224 in range(_size220):
                        _elem225 = iprot.readI32()
                        self.non_behavioral.append(_elem225)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype229, _size226) = iprot.readListBegin()
                    for _i230 in range(_size226):
                        _elem231 = DiscreteInputArchitecture()
                        _elem231.read(iprot)
                        self.all_archs.append(_elem231)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.featureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.logical_connective = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesDiscrete_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 2)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter232 in self.behavioral:
                oprot.writeI32(iter232)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter233 in self.non_behavioral:
                oprot.writeI32(iter233)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter234 in self.all_archs:
                iter234.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.featureExpression is not None:
            oprot.writeFieldBegin('featureExpression', TType.STRING, 6)
            oprot.writeString(self.featureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.featureExpression)
            oprot.writeFieldEnd()
        if self.logical_connective is not None:
            oprot.writeFieldBegin('logical_connective', TType.STRING, 7)
            oprot.writeString(self.logical_connective.encode('utf-8') if sys.version_info[0] == 2 else self.logical_connective)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesDiscrete_args)
getMarginalDrivingFeaturesDiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'problem', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 5
    (6, TType.STRING, 'featureExpression', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'logical_connective', 'UTF8', None, ),  # 7
)


class getMarginalDrivingFeaturesDiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype238, _size235) = iprot.readListBegin()
                    for _i239 in range(_size235):
                        _elem240 = Feature()
                        _elem240.read(iprot)
                        self.success.append(_elem240)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesDiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter241 in self.success:
                iter241.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesDiscrete_result)
getMarginalDrivingFeaturesDiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesEpsilonMOEADiscrete_args(object):
    """
    Attributes:
     - session
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, session=None, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.session = session
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype245, _size242) = iprot.readListBegin()
                    for _i246 in range(_size242):
                        _elem247 = iprot.readI32()
                        self.behavioral.append(_elem247)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype251, _size248) = iprot.readListBegin()
                    for _i252 in range(_size248):
                        _elem253 = iprot.readI32()
                        self.non_behavioral.append(_elem253)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype257, _size254) = iprot.readListBegin()
                    for _i258 in range(_size254):
                        _elem259 = DiscreteInputArchitecture()
                        _elem259.read(iprot)
                        self.all_archs.append(_elem259)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEADiscrete_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 2)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter260 in self.behavioral:
                oprot.writeI32(iter260)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter261 in self.non_behavioral:
                oprot.writeI32(iter261)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter262 in self.all_archs:
                iter262.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEADiscrete_args)
getDrivingFeaturesEpsilonMOEADiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'problem', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 5
)


class getDrivingFeaturesEpsilonMOEADiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype266, _size263) = iprot.readListBegin()
                    for _i267 in range(_size263):
                        _elem268 = Feature()
                        _elem268.read(iprot)
                        self.success.append(_elem268)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEADiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter269 in self.success:
                iter269.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEADiscrete_result)
getDrivingFeaturesEpsilonMOEADiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesContinuous_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype273, _size270) = iprot.readListBegin()
                    for _i274 in range(_size270):
                        _elem275 = iprot.readI32()
                        self.behavioral.append(_elem275)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype279, _size276) = iprot.readListBegin()
                    for _i280 in range(_size276):
                        _elem281 = iprot.readI32()
                        self.non_behavioral.append(_elem281)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype285, _size282) = iprot.readListBegin()
                    for _i286 in range(_size282):
                        _elem287 = ContinuousInputArchitecture()
                        _elem287.read(iprot)
                        self.all_archs.append(_elem287)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesContinuous_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter288 in self.behavioral:
                oprot.writeI32(iter288)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter289 in self.non_behavioral:
                oprot.writeI32(iter289)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter290 in self.all_archs:
                iter290.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesContinuous_args)
getDrivingFeaturesContinuous_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [ContinuousInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class getDrivingFeaturesContinuous_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = Feature()
                        _elem296.read(iprot)
                        self.success.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesContinuous_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter297 in self.success:
                iter297.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesContinuous_result)
getDrivingFeaturesContinuous_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesEpsilonMOEAContinuous_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype301, _size298) = iprot.readListBegin()
                    for _i302 in range(_size298):
                        _elem303 = iprot.readI32()
                        self.behavioral.append(_elem303)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype307, _size304) = iprot.readListBegin()
                    for _i308 in range(_size304):
                        _elem309 = iprot.readI32()
                        self.non_behavioral.append(_elem309)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype313, _size310) = iprot.readListBegin()
                    for _i314 in range(_size310):
                        _elem315 = ContinuousInputArchitecture()
                        _elem315.read(iprot)
                        self.all_archs.append(_elem315)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEAContinuous_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter316 in self.behavioral:
                oprot.writeI32(iter316)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter317 in self.non_behavioral:
                oprot.writeI32(iter317)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter318 in self.all_archs:
                iter318.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEAContinuous_args)
getDrivingFeaturesEpsilonMOEAContinuous_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [ContinuousInputArchitecture, None], False), None, ),  # 4
)


class getDrivingFeaturesEpsilonMOEAContinuous_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype322, _size319) = iprot.readListBegin()
                    for _i323 in range(_size319):
                        _elem324 = Feature()
                        _elem324.read(iprot)
                        self.success.append(_elem324)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEAContinuous_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter325 in self.success:
                iter325.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEAContinuous_result)
getDrivingFeaturesEpsilonMOEAContinuous_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class generalizeFeatureBinary_args(object):
    """
    Attributes:
     - session
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - rootfeatureExpression
     - nodeFeatureExpression
    """


    def __init__(self, session=None, problem=None, behavioral=None, non_behavioral=None, all_archs=None, rootfeatureExpression=None, nodeFeatureExpression=None,):
        self.session = session
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.rootfeatureExpression = rootfeatureExpression
        self.nodeFeatureExpression = nodeFeatureExpression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype329, _size326) = iprot.readListBegin()
                    for _i330 in range(_size326):
                        _elem331 = iprot.readI32()
                        self.behavioral.append(_elem331)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype335, _size332) = iprot.readListBegin()
                    for _i336 in range(_size332):
                        _elem337 = iprot.readI32()
                        self.non_behavioral.append(_elem337)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype341, _size338) = iprot.readListBegin()
                    for _i342 in range(_size338):
                        _elem343 = BinaryInputArchitecture()
                        _elem343.read(iprot)
                        self.all_archs.append(_elem343)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.rootfeatureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.nodeFeatureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('generalizeFeatureBinary_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 2)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter344 in self.behavioral:
                oprot.writeI32(iter344)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter345 in self.non_behavioral:
                oprot.writeI32(iter345)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter346 in self.all_archs:
                iter346.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rootfeatureExpression is not None:
            oprot.writeFieldBegin('rootfeatureExpression', TType.STRING, 6)
            oprot.writeString(self.rootfeatureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.rootfeatureExpression)
            oprot.writeFieldEnd()
        if self.nodeFeatureExpression is not None:
            oprot.writeFieldBegin('nodeFeatureExpression', TType.STRING, 7)
            oprot.writeString(self.nodeFeatureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.nodeFeatureExpression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(generalizeFeatureBinary_args)
generalizeFeatureBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'problem', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 5
    (6, TType.STRING, 'rootfeatureExpression', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'nodeFeatureExpression', 'UTF8', None, ),  # 7
)


class generalizeFeatureBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('generalizeFeatureBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(generalizeFeatureBinary_result)
generalizeFeatureBinary_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class getDrivingFeaturesWithGeneralizationBinary_args(object):
    """
    Attributes:
     - session
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, session=None, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.session = session
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype350, _size347) = iprot.readListBegin()
                    for _i351 in range(_size347):
                        _elem352 = iprot.readI32()
                        self.behavioral.append(_elem352)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype356, _size353) = iprot.readListBegin()
                    for _i357 in range(_size353):
                        _elem358 = iprot.readI32()
                        self.non_behavioral.append(_elem358)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype362, _size359) = iprot.readListBegin()
                    for _i363 in range(_size359):
                        _elem364 = BinaryInputArchitecture()
                        _elem364.read(iprot)
                        self.all_archs.append(_elem364)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesWithGeneralizationBinary_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 2)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter365 in self.behavioral:
                oprot.writeI32(iter365)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter366 in self.non_behavioral:
                oprot.writeI32(iter366)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter367 in self.all_archs:
                iter367.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesWithGeneralizationBinary_args)
getDrivingFeaturesWithGeneralizationBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'problem', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 5
)


class getDrivingFeaturesWithGeneralizationBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype371, _size368) = iprot.readListBegin()
                    for _i372 in range(_size368):
                        _elem373 = Feature()
                        _elem373.read(iprot)
                        self.success.append(_elem373)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesWithGeneralizationBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter374 in self.success:
                iter374.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesWithGeneralizationBinary_result)
getDrivingFeaturesWithGeneralizationBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class simplifyFeatureExpression_args(object):
    """
    Attributes:
     - session
     - problem
     - expression
    """


    def __init__(self, session=None, problem=None, expression=None,):
        self.session = session
        self.problem = problem
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simplifyFeatureExpression_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 2)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 3)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simplifyFeatureExpression_args)
simplifyFeatureExpression_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'problem', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'expression', 'UTF8', None, ),  # 3
)


class simplifyFeatureExpression_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simplifyFeatureExpression_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simplifyFeatureExpression_result)
simplifyFeatureExpression_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class stopSearch_args(object):
    """
    Attributes:
     - session
    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopSearch_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopSearch_args)
stopSearch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class stopSearch_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopSearch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopSearch_result)
stopSearch_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class computeComplexityOfFeatures_args(object):
    """
    Attributes:
     - expressions
    """


    def __init__(self, expressions=None,):
        self.expressions = expressions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.expressions = []
                    (_etype378, _size375) = iprot.readListBegin()
                    for _i379 in range(_size375):
                        _elem380 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.expressions.append(_elem380)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexityOfFeatures_args')
        if self.expressions is not None:
            oprot.writeFieldBegin('expressions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.expressions))
            for iter381 in self.expressions:
                oprot.writeString(iter381.encode('utf-8') if sys.version_info[0] == 2 else iter381)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexityOfFeatures_args)
computeComplexityOfFeatures_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'expressions', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class computeComplexityOfFeatures_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype385, _size382) = iprot.readListBegin()
                    for _i386 in range(_size382):
                        _elem387 = iprot.readDouble()
                        self.success.append(_elem387)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexityOfFeatures_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter388 in self.success:
                oprot.writeDouble(iter388)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexityOfFeatures_result)
computeComplexityOfFeatures_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class computeAlgebraicTypicality_args(object):
    """
    Attributes:
     - problem
     - arch
     - feature
    """


    def __init__(self, problem=None, arch=None, feature=None,):
        self.problem = problem
        self.arch = arch
        self.feature = feature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.feature = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicality_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        if self.feature is not None:
            oprot.writeFieldBegin('feature', TType.STRING, 3)
            oprot.writeString(self.feature.encode('utf-8') if sys.version_info[0] == 2 else self.feature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicality_args)
computeAlgebraicTypicality_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
    (3, TType.STRING, 'feature', 'UTF8', None, ),  # 3
)


class computeAlgebraicTypicality_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype392, _size389) = iprot.readListBegin()
                    for _i393 in range(_size389):
                        _elem394 = iprot.readI32()
                        self.success.append(_elem394)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicality_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter395 in self.success:
                oprot.writeI32(iter395)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicality_result)
computeAlgebraicTypicality_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class computeComplexity_args(object):
    """
    Attributes:
     - expression
    """


    def __init__(self, expression=None,):
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexity_args')
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 1)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexity_args)
computeComplexity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expression', 'UTF8', None, ),  # 1
)


class computeComplexity_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexity_result)
computeComplexity_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class convertToCNF_args(object):
    """
    Attributes:
     - expression
    """


    def __init__(self, expression=None,):
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToCNF_args')
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 1)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToCNF_args)
convertToCNF_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expression', 'UTF8', None, ),  # 1
)


class convertToCNF_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToCNF_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToCNF_result)
convertToCNF_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class convertToDNF_args(object):
    """
    Attributes:
     - expression
    """


    def __init__(self, expression=None,):
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToDNF_args')
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 1)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToDNF_args)
convertToDNF_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expression', 'UTF8', None, ),  # 1
)


class convertToDNF_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToDNF_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToDNF_result)
convertToDNF_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class setAssigningProblemEntities_args(object):
    """
    Attributes:
     - session
     - problem
     - entities
    """


    def __init__(self, session=None, problem=None, entities=None,):
        self.session = session
        self.problem = problem
        self.entities = entities

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.entities = AssigningProblemEntities()
                    self.entities.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAssigningProblemEntities_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 2)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.entities is not None:
            oprot.writeFieldBegin('entities', TType.STRUCT, 3)
            self.entities.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAssigningProblemEntities_args)
setAssigningProblemEntities_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'problem', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'entities', [AssigningProblemEntities, None], None, ),  # 3
)


class setAssigningProblemEntities_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAssigningProblemEntities_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAssigningProblemEntities_result)
setAssigningProblemEntities_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class setAssigningProblemGeneralizedConcepts_args(object):
    """
    Attributes:
     - session
     - problem
     - generalizedConcepts
    """


    def __init__(self, session=None, problem=None, generalizedConcepts=None,):
        self.session = session
        self.problem = problem
        self.generalizedConcepts = generalizedConcepts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.generalizedConcepts = AssigningProblemEntities()
                    self.generalizedConcepts.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAssigningProblemGeneralizedConcepts_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 2)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.generalizedConcepts is not None:
            oprot.writeFieldBegin('generalizedConcepts', TType.STRUCT, 3)
            self.generalizedConcepts.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAssigningProblemGeneralizedConcepts_args)
setAssigningProblemGeneralizedConcepts_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'problem', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'generalizedConcepts', [AssigningProblemEntities, None], None, ),  # 3
)


class setAssigningProblemGeneralizedConcepts_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAssigningProblemGeneralizedConcepts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAssigningProblemGeneralizedConcepts_result)
setAssigningProblemGeneralizedConcepts_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class getAssigningProblemEntities_args(object):
    """
    Attributes:
     - session
     - problem
    """


    def __init__(self, session=None, problem=None,):
        self.session = session
        self.problem = problem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAssigningProblemEntities_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 2)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAssigningProblemEntities_args)
getAssigningProblemEntities_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'problem', 'UTF8', None, ),  # 2
)


class getAssigningProblemEntities_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AssigningProblemEntities()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAssigningProblemEntities_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAssigningProblemEntities_result)
getAssigningProblemEntities_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [AssigningProblemEntities, None], None, ),  # 0
)


class getAssigningProblemConceptHierarchy_args(object):
    """
    Attributes:
     - session
     - problem
     - params
    """


    def __init__(self, session=None, problem=None, params=None,):
        self.session = session
        self.problem = problem
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.params = AssigningProblemEntities()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAssigningProblemConceptHierarchy_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 2)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 3)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAssigningProblemConceptHierarchy_args)
getAssigningProblemConceptHierarchy_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'problem', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'params', [AssigningProblemEntities, None], None, ),  # 3
)


class getAssigningProblemConceptHierarchy_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FlattenedConceptHierarchy()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAssigningProblemConceptHierarchy_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAssigningProblemConceptHierarchy_result)
getAssigningProblemConceptHierarchy_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FlattenedConceptHierarchy, None], None, ),  # 0
)


class computeAlgebraicTypicalityWithStringInput_args(object):
    """
    Attributes:
     - problem
     - architecture
     - feature
    """


    def __init__(self, problem=None, architecture=None, feature=None,):
        self.problem = problem
        self.architecture = architecture
        self.feature = feature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.architecture = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.feature = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicalityWithStringInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.architecture is not None:
            oprot.writeFieldBegin('architecture', TType.STRING, 2)
            oprot.writeString(self.architecture.encode('utf-8') if sys.version_info[0] == 2 else self.architecture)
            oprot.writeFieldEnd()
        if self.feature is not None:
            oprot.writeFieldBegin('feature', TType.STRING, 3)
            oprot.writeString(self.feature.encode('utf-8') if sys.version_info[0] == 2 else self.feature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicalityWithStringInput_args)
computeAlgebraicTypicalityWithStringInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'architecture', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'feature', 'UTF8', None, ),  # 3
)


class computeAlgebraicTypicalityWithStringInput_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype399, _size396) = iprot.readListBegin()
                    for _i400 in range(_size396):
                        _elem401 = iprot.readI32()
                        self.success.append(_elem401)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicalityWithStringInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter402 in self.success:
                oprot.writeI32(iter402)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicalityWithStringInput_result)
computeAlgebraicTypicalityWithStringInput_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)
fix_spec(all_structs)
del all_structs

