#
# Autogenerated by Thrift Compiler (0.12.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def ping(self):
        """
        A method definition looks like C code. It has a return type, arguments,
        and optionally a list of exceptions that it may throw. Note that argument
        lists and exception lists are specified using the exact same syntax as
        field lists in struct or exception definitions.

        """
        pass

    def evalBinaryInputArch(self, problem, inputs):
        """
        Parameters:
         - problem
         - inputs

        """
        pass

    def evalDiscreteInputArch(self, problem, inputs):
        """
        Parameters:
         - problem
         - inputs

        """
        pass

    def runLocalSearchBinaryInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        pass

    def runLocalSearchDiscreteInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        pass

    def getOrbitList(self, problem):
        """
        Parameters:
         - problem

        """
        pass

    def getInstrumentList(self, problem):
        """
        Parameters:
         - problem

        """
        pass

    def getObjectiveList(self, problem):
        """
        Parameters:
         - problem

        """
        pass

    def getSubobjectiveList(self, problem):
        """
        Parameters:
         - problem

        """
        pass

    def getInstrumentsForObjective(self, problem, objective):
        """
        Parameters:
         - problem
         - objective

        """
        pass

    def getInstrumentsForPanel(self, problem, panel):
        """
        Parameters:
         - problem
         - panel

        """
        pass

    def getCritiqueBinaryInputArch(self, problem, inputs):
        """
        Parameters:
         - problem
         - inputs

        """
        pass

    def getCritiqueDiscreteInputArch(self, problem, inputs):
        """
        Parameters:
         - problem
         - inputs

        """
        pass

    def getArchitectureScoreExplanation(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        pass

    def getPanelScoreExplanation(self, problem, arch, panel):
        """
        Parameters:
         - problem
         - arch
         - panel

        """
        pass

    def getObjectiveScoreExplanation(self, problem, arch, objective):
        """
        Parameters:
         - problem
         - arch
         - objective

        """
        pass

    def isGARunning(self, id):
        """
        Parameters:
         - id

        """
        pass

    def stopGA(self, id):
        """
        Parameters:
         - id

        """
        pass

    def startGABinaryInput(self, problem, dataset, username):
        """
        Parameters:
         - problem
         - dataset
         - username

        """
        pass

    def startGADiscreteInput(self, problem, dataset, username):
        """
        Parameters:
         - problem
         - dataset
         - username

        """
        pass

    def startGAScheduling(self, problem, dataset, inputArches, historicalInfo, username):
        """
        Parameters:
         - problem
         - dataset
         - inputArches
         - historicalInfo
         - username

        """
        pass

    def getArchScienceInformationBinaryInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        pass

    def getArchCostInformationBinaryInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        pass

    def getSubscoreDetailsBinaryInput(self, problem, arch, subobj):
        """
        Parameters:
         - problem
         - arch
         - subobj

        """
        pass

    def getArchScienceInformationDiscreteInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        pass

    def getArchCostInformationDiscreteInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        pass

    def getSubscoreDetailsDiscreteInput(self, problem, arch, subobj):
        """
        Parameters:
         - problem
         - arch
         - subobj

        """
        pass

    def getCommonMeasurements(self, problem, arch_list):
        """
        Parameters:
         - problem
         - arch_list

        """
        pass

    def getMeasurements(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        pass

    def getPanelScoresForArch(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        pass

    def evaluateDataContinuityScore(self, missionMeasurements, historical_missionMeasurements):
        """
        Parameters:
         - missionMeasurements
         - historical_missionMeasurements

        """
        pass

    def evaluateFairnessScore(self, missionMeasurements):
        """
        Parameters:
         - missionMeasurements

        """
        pass

    def enumeratedDesigns(self, problem, input_arches, historical_info):
        """
        Parameters:
         - problem
         - input_arches
         - historical_info

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def ping(self):
        """
        A method definition looks like C code. It has a return type, arguments,
        and optionally a list of exceptions that it may throw. Note that argument
        lists and exception lists are specified using the exact same syntax as
        field lists in struct or exception definitions.

        """
        self.send_ping()
        self.recv_ping()

    def send_ping(self):
        self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
        args = ping_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def evalBinaryInputArch(self, problem, inputs):
        """
        Parameters:
         - problem
         - inputs

        """
        self.send_evalBinaryInputArch(problem, inputs)
        return self.recv_evalBinaryInputArch()

    def send_evalBinaryInputArch(self, problem, inputs):
        self._oprot.writeMessageBegin('evalBinaryInputArch', TMessageType.CALL, self._seqid)
        args = evalBinaryInputArch_args()
        args.problem = problem
        args.inputs = inputs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_evalBinaryInputArch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = evalBinaryInputArch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "evalBinaryInputArch failed: unknown result")

    def evalDiscreteInputArch(self, problem, inputs):
        """
        Parameters:
         - problem
         - inputs

        """
        self.send_evalDiscreteInputArch(problem, inputs)
        return self.recv_evalDiscreteInputArch()

    def send_evalDiscreteInputArch(self, problem, inputs):
        self._oprot.writeMessageBegin('evalDiscreteInputArch', TMessageType.CALL, self._seqid)
        args = evalDiscreteInputArch_args()
        args.problem = problem
        args.inputs = inputs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_evalDiscreteInputArch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = evalDiscreteInputArch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "evalDiscreteInputArch failed: unknown result")

    def runLocalSearchBinaryInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        self.send_runLocalSearchBinaryInput(problem, arch)
        return self.recv_runLocalSearchBinaryInput()

    def send_runLocalSearchBinaryInput(self, problem, arch):
        self._oprot.writeMessageBegin('runLocalSearchBinaryInput', TMessageType.CALL, self._seqid)
        args = runLocalSearchBinaryInput_args()
        args.problem = problem
        args.arch = arch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runLocalSearchBinaryInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runLocalSearchBinaryInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "runLocalSearchBinaryInput failed: unknown result")

    def runLocalSearchDiscreteInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        self.send_runLocalSearchDiscreteInput(problem, arch)
        return self.recv_runLocalSearchDiscreteInput()

    def send_runLocalSearchDiscreteInput(self, problem, arch):
        self._oprot.writeMessageBegin('runLocalSearchDiscreteInput', TMessageType.CALL, self._seqid)
        args = runLocalSearchDiscreteInput_args()
        args.problem = problem
        args.arch = arch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runLocalSearchDiscreteInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runLocalSearchDiscreteInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "runLocalSearchDiscreteInput failed: unknown result")

    def getOrbitList(self, problem):
        """
        Parameters:
         - problem

        """
        self.send_getOrbitList(problem)
        return self.recv_getOrbitList()

    def send_getOrbitList(self, problem):
        self._oprot.writeMessageBegin('getOrbitList', TMessageType.CALL, self._seqid)
        args = getOrbitList_args()
        args.problem = problem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getOrbitList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getOrbitList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getOrbitList failed: unknown result")

    def getInstrumentList(self, problem):
        """
        Parameters:
         - problem

        """
        self.send_getInstrumentList(problem)
        return self.recv_getInstrumentList()

    def send_getInstrumentList(self, problem):
        self._oprot.writeMessageBegin('getInstrumentList', TMessageType.CALL, self._seqid)
        args = getInstrumentList_args()
        args.problem = problem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getInstrumentList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getInstrumentList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getInstrumentList failed: unknown result")

    def getObjectiveList(self, problem):
        """
        Parameters:
         - problem

        """
        self.send_getObjectiveList(problem)
        return self.recv_getObjectiveList()

    def send_getObjectiveList(self, problem):
        self._oprot.writeMessageBegin('getObjectiveList', TMessageType.CALL, self._seqid)
        args = getObjectiveList_args()
        args.problem = problem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getObjectiveList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getObjectiveList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getObjectiveList failed: unknown result")

    def getSubobjectiveList(self, problem):
        """
        Parameters:
         - problem

        """
        self.send_getSubobjectiveList(problem)
        return self.recv_getSubobjectiveList()

    def send_getSubobjectiveList(self, problem):
        self._oprot.writeMessageBegin('getSubobjectiveList', TMessageType.CALL, self._seqid)
        args = getSubobjectiveList_args()
        args.problem = problem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSubobjectiveList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSubobjectiveList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSubobjectiveList failed: unknown result")

    def getInstrumentsForObjective(self, problem, objective):
        """
        Parameters:
         - problem
         - objective

        """
        self.send_getInstrumentsForObjective(problem, objective)
        return self.recv_getInstrumentsForObjective()

    def send_getInstrumentsForObjective(self, problem, objective):
        self._oprot.writeMessageBegin('getInstrumentsForObjective', TMessageType.CALL, self._seqid)
        args = getInstrumentsForObjective_args()
        args.problem = problem
        args.objective = objective
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getInstrumentsForObjective(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getInstrumentsForObjective_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getInstrumentsForObjective failed: unknown result")

    def getInstrumentsForPanel(self, problem, panel):
        """
        Parameters:
         - problem
         - panel

        """
        self.send_getInstrumentsForPanel(problem, panel)
        return self.recv_getInstrumentsForPanel()

    def send_getInstrumentsForPanel(self, problem, panel):
        self._oprot.writeMessageBegin('getInstrumentsForPanel', TMessageType.CALL, self._seqid)
        args = getInstrumentsForPanel_args()
        args.problem = problem
        args.panel = panel
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getInstrumentsForPanel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getInstrumentsForPanel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getInstrumentsForPanel failed: unknown result")

    def getCritiqueBinaryInputArch(self, problem, inputs):
        """
        Parameters:
         - problem
         - inputs

        """
        self.send_getCritiqueBinaryInputArch(problem, inputs)
        return self.recv_getCritiqueBinaryInputArch()

    def send_getCritiqueBinaryInputArch(self, problem, inputs):
        self._oprot.writeMessageBegin('getCritiqueBinaryInputArch', TMessageType.CALL, self._seqid)
        args = getCritiqueBinaryInputArch_args()
        args.problem = problem
        args.inputs = inputs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCritiqueBinaryInputArch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCritiqueBinaryInputArch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCritiqueBinaryInputArch failed: unknown result")

    def getCritiqueDiscreteInputArch(self, problem, inputs):
        """
        Parameters:
         - problem
         - inputs

        """
        self.send_getCritiqueDiscreteInputArch(problem, inputs)
        return self.recv_getCritiqueDiscreteInputArch()

    def send_getCritiqueDiscreteInputArch(self, problem, inputs):
        self._oprot.writeMessageBegin('getCritiqueDiscreteInputArch', TMessageType.CALL, self._seqid)
        args = getCritiqueDiscreteInputArch_args()
        args.problem = problem
        args.inputs = inputs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCritiqueDiscreteInputArch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCritiqueDiscreteInputArch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCritiqueDiscreteInputArch failed: unknown result")

    def getArchitectureScoreExplanation(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        self.send_getArchitectureScoreExplanation(problem, arch)
        return self.recv_getArchitectureScoreExplanation()

    def send_getArchitectureScoreExplanation(self, problem, arch):
        self._oprot.writeMessageBegin('getArchitectureScoreExplanation', TMessageType.CALL, self._seqid)
        args = getArchitectureScoreExplanation_args()
        args.problem = problem
        args.arch = arch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getArchitectureScoreExplanation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getArchitectureScoreExplanation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getArchitectureScoreExplanation failed: unknown result")

    def getPanelScoreExplanation(self, problem, arch, panel):
        """
        Parameters:
         - problem
         - arch
         - panel

        """
        self.send_getPanelScoreExplanation(problem, arch, panel)
        return self.recv_getPanelScoreExplanation()

    def send_getPanelScoreExplanation(self, problem, arch, panel):
        self._oprot.writeMessageBegin('getPanelScoreExplanation', TMessageType.CALL, self._seqid)
        args = getPanelScoreExplanation_args()
        args.problem = problem
        args.arch = arch
        args.panel = panel
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPanelScoreExplanation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPanelScoreExplanation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPanelScoreExplanation failed: unknown result")

    def getObjectiveScoreExplanation(self, problem, arch, objective):
        """
        Parameters:
         - problem
         - arch
         - objective

        """
        self.send_getObjectiveScoreExplanation(problem, arch, objective)
        return self.recv_getObjectiveScoreExplanation()

    def send_getObjectiveScoreExplanation(self, problem, arch, objective):
        self._oprot.writeMessageBegin('getObjectiveScoreExplanation', TMessageType.CALL, self._seqid)
        args = getObjectiveScoreExplanation_args()
        args.problem = problem
        args.arch = arch
        args.objective = objective
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getObjectiveScoreExplanation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getObjectiveScoreExplanation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getObjectiveScoreExplanation failed: unknown result")

    def isGARunning(self, id):
        """
        Parameters:
         - id

        """
        self.send_isGARunning(id)
        return self.recv_isGARunning()

    def send_isGARunning(self, id):
        self._oprot.writeMessageBegin('isGARunning', TMessageType.CALL, self._seqid)
        args = isGARunning_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isGARunning(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isGARunning_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isGARunning failed: unknown result")

    def stopGA(self, id):
        """
        Parameters:
         - id

        """
        self.send_stopGA(id)
        return self.recv_stopGA()

    def send_stopGA(self, id):
        self._oprot.writeMessageBegin('stopGA', TMessageType.CALL, self._seqid)
        args = stopGA_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stopGA(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stopGA_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stopGA failed: unknown result")

    def startGABinaryInput(self, problem, dataset, username):
        """
        Parameters:
         - problem
         - dataset
         - username

        """
        self.send_startGABinaryInput(problem, dataset, username)
        return self.recv_startGABinaryInput()

    def send_startGABinaryInput(self, problem, dataset, username):
        self._oprot.writeMessageBegin('startGABinaryInput', TMessageType.CALL, self._seqid)
        args = startGABinaryInput_args()
        args.problem = problem
        args.dataset = dataset
        args.username = username
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_startGABinaryInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = startGABinaryInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "startGABinaryInput failed: unknown result")

    def startGADiscreteInput(self, problem, dataset, username):
        """
        Parameters:
         - problem
         - dataset
         - username

        """
        self.send_startGADiscreteInput(problem, dataset, username)
        return self.recv_startGADiscreteInput()

    def send_startGADiscreteInput(self, problem, dataset, username):
        self._oprot.writeMessageBegin('startGADiscreteInput', TMessageType.CALL, self._seqid)
        args = startGADiscreteInput_args()
        args.problem = problem
        args.dataset = dataset
        args.username = username
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_startGADiscreteInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = startGADiscreteInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "startGADiscreteInput failed: unknown result")

    def startGAScheduling(self, problem, dataset, inputArches, historicalInfo, username):
        """
        Parameters:
         - problem
         - dataset
         - inputArches
         - historicalInfo
         - username

        """
        self.send_startGAScheduling(problem, dataset, inputArches, historicalInfo, username)
        return self.recv_startGAScheduling()

    def send_startGAScheduling(self, problem, dataset, inputArches, historicalInfo, username):
        self._oprot.writeMessageBegin('startGAScheduling', TMessageType.CALL, self._seqid)
        args = startGAScheduling_args()
        args.problem = problem
        args.dataset = dataset
        args.inputArches = inputArches
        args.historicalInfo = historicalInfo
        args.username = username
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_startGAScheduling(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = startGAScheduling_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "startGAScheduling failed: unknown result")

    def getArchScienceInformationBinaryInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        self.send_getArchScienceInformationBinaryInput(problem, arch)
        return self.recv_getArchScienceInformationBinaryInput()

    def send_getArchScienceInformationBinaryInput(self, problem, arch):
        self._oprot.writeMessageBegin('getArchScienceInformationBinaryInput', TMessageType.CALL, self._seqid)
        args = getArchScienceInformationBinaryInput_args()
        args.problem = problem
        args.arch = arch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getArchScienceInformationBinaryInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getArchScienceInformationBinaryInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getArchScienceInformationBinaryInput failed: unknown result")

    def getArchCostInformationBinaryInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        self.send_getArchCostInformationBinaryInput(problem, arch)
        return self.recv_getArchCostInformationBinaryInput()

    def send_getArchCostInformationBinaryInput(self, problem, arch):
        self._oprot.writeMessageBegin('getArchCostInformationBinaryInput', TMessageType.CALL, self._seqid)
        args = getArchCostInformationBinaryInput_args()
        args.problem = problem
        args.arch = arch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getArchCostInformationBinaryInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getArchCostInformationBinaryInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getArchCostInformationBinaryInput failed: unknown result")

    def getSubscoreDetailsBinaryInput(self, problem, arch, subobj):
        """
        Parameters:
         - problem
         - arch
         - subobj

        """
        self.send_getSubscoreDetailsBinaryInput(problem, arch, subobj)
        return self.recv_getSubscoreDetailsBinaryInput()

    def send_getSubscoreDetailsBinaryInput(self, problem, arch, subobj):
        self._oprot.writeMessageBegin('getSubscoreDetailsBinaryInput', TMessageType.CALL, self._seqid)
        args = getSubscoreDetailsBinaryInput_args()
        args.problem = problem
        args.arch = arch
        args.subobj = subobj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSubscoreDetailsBinaryInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSubscoreDetailsBinaryInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSubscoreDetailsBinaryInput failed: unknown result")

    def getArchScienceInformationDiscreteInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        self.send_getArchScienceInformationDiscreteInput(problem, arch)
        return self.recv_getArchScienceInformationDiscreteInput()

    def send_getArchScienceInformationDiscreteInput(self, problem, arch):
        self._oprot.writeMessageBegin('getArchScienceInformationDiscreteInput', TMessageType.CALL, self._seqid)
        args = getArchScienceInformationDiscreteInput_args()
        args.problem = problem
        args.arch = arch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getArchScienceInformationDiscreteInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getArchScienceInformationDiscreteInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getArchScienceInformationDiscreteInput failed: unknown result")

    def getArchCostInformationDiscreteInput(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        self.send_getArchCostInformationDiscreteInput(problem, arch)
        return self.recv_getArchCostInformationDiscreteInput()

    def send_getArchCostInformationDiscreteInput(self, problem, arch):
        self._oprot.writeMessageBegin('getArchCostInformationDiscreteInput', TMessageType.CALL, self._seqid)
        args = getArchCostInformationDiscreteInput_args()
        args.problem = problem
        args.arch = arch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getArchCostInformationDiscreteInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getArchCostInformationDiscreteInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getArchCostInformationDiscreteInput failed: unknown result")

    def getSubscoreDetailsDiscreteInput(self, problem, arch, subobj):
        """
        Parameters:
         - problem
         - arch
         - subobj

        """
        self.send_getSubscoreDetailsDiscreteInput(problem, arch, subobj)
        return self.recv_getSubscoreDetailsDiscreteInput()

    def send_getSubscoreDetailsDiscreteInput(self, problem, arch, subobj):
        self._oprot.writeMessageBegin('getSubscoreDetailsDiscreteInput', TMessageType.CALL, self._seqid)
        args = getSubscoreDetailsDiscreteInput_args()
        args.problem = problem
        args.arch = arch
        args.subobj = subobj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSubscoreDetailsDiscreteInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSubscoreDetailsDiscreteInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSubscoreDetailsDiscreteInput failed: unknown result")

    def getCommonMeasurements(self, problem, arch_list):
        """
        Parameters:
         - problem
         - arch_list

        """
        self.send_getCommonMeasurements(problem, arch_list)
        return self.recv_getCommonMeasurements()

    def send_getCommonMeasurements(self, problem, arch_list):
        self._oprot.writeMessageBegin('getCommonMeasurements', TMessageType.CALL, self._seqid)
        args = getCommonMeasurements_args()
        args.problem = problem
        args.arch_list = arch_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCommonMeasurements(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCommonMeasurements_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCommonMeasurements failed: unknown result")

    def getMeasurements(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        self.send_getMeasurements(problem, arch)
        return self.recv_getMeasurements()

    def send_getMeasurements(self, problem, arch):
        self._oprot.writeMessageBegin('getMeasurements', TMessageType.CALL, self._seqid)
        args = getMeasurements_args()
        args.problem = problem
        args.arch = arch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMeasurements(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMeasurements_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMeasurements failed: unknown result")

    def getPanelScoresForArch(self, problem, arch):
        """
        Parameters:
         - problem
         - arch

        """
        self.send_getPanelScoresForArch(problem, arch)
        return self.recv_getPanelScoresForArch()

    def send_getPanelScoresForArch(self, problem, arch):
        self._oprot.writeMessageBegin('getPanelScoresForArch', TMessageType.CALL, self._seqid)
        args = getPanelScoresForArch_args()
        args.problem = problem
        args.arch = arch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPanelScoresForArch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPanelScoresForArch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPanelScoresForArch failed: unknown result")

    def evaluateDataContinuityScore(self, missionMeasurements, historical_missionMeasurements):
        """
        Parameters:
         - missionMeasurements
         - historical_missionMeasurements

        """
        self.send_evaluateDataContinuityScore(missionMeasurements, historical_missionMeasurements)
        return self.recv_evaluateDataContinuityScore()

    def send_evaluateDataContinuityScore(self, missionMeasurements, historical_missionMeasurements):
        self._oprot.writeMessageBegin('evaluateDataContinuityScore', TMessageType.CALL, self._seqid)
        args = evaluateDataContinuityScore_args()
        args.missionMeasurements = missionMeasurements
        args.historical_missionMeasurements = historical_missionMeasurements
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_evaluateDataContinuityScore(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = evaluateDataContinuityScore_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "evaluateDataContinuityScore failed: unknown result")

    def evaluateFairnessScore(self, missionMeasurements):
        """
        Parameters:
         - missionMeasurements

        """
        self.send_evaluateFairnessScore(missionMeasurements)
        return self.recv_evaluateFairnessScore()

    def send_evaluateFairnessScore(self, missionMeasurements):
        self._oprot.writeMessageBegin('evaluateFairnessScore', TMessageType.CALL, self._seqid)
        args = evaluateFairnessScore_args()
        args.missionMeasurements = missionMeasurements
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_evaluateFairnessScore(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = evaluateFairnessScore_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "evaluateFairnessScore failed: unknown result")

    def enumeratedDesigns(self, problem, input_arches, historical_info):
        """
        Parameters:
         - problem
         - input_arches
         - historical_info

        """
        self.send_enumeratedDesigns(problem, input_arches, historical_info)
        return self.recv_enumeratedDesigns()

    def send_enumeratedDesigns(self, problem, input_arches, historical_info):
        self._oprot.writeMessageBegin('enumeratedDesigns', TMessageType.CALL, self._seqid)
        args = enumeratedDesigns_args()
        args.problem = problem
        args.input_arches = input_arches
        args.historical_info = historical_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enumeratedDesigns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enumeratedDesigns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enumeratedDesigns failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["ping"] = Processor.process_ping
        self._processMap["evalBinaryInputArch"] = Processor.process_evalBinaryInputArch
        self._processMap["evalDiscreteInputArch"] = Processor.process_evalDiscreteInputArch
        self._processMap["runLocalSearchBinaryInput"] = Processor.process_runLocalSearchBinaryInput
        self._processMap["runLocalSearchDiscreteInput"] = Processor.process_runLocalSearchDiscreteInput
        self._processMap["getOrbitList"] = Processor.process_getOrbitList
        self._processMap["getInstrumentList"] = Processor.process_getInstrumentList
        self._processMap["getObjectiveList"] = Processor.process_getObjectiveList
        self._processMap["getSubobjectiveList"] = Processor.process_getSubobjectiveList
        self._processMap["getInstrumentsForObjective"] = Processor.process_getInstrumentsForObjective
        self._processMap["getInstrumentsForPanel"] = Processor.process_getInstrumentsForPanel
        self._processMap["getCritiqueBinaryInputArch"] = Processor.process_getCritiqueBinaryInputArch
        self._processMap["getCritiqueDiscreteInputArch"] = Processor.process_getCritiqueDiscreteInputArch
        self._processMap["getArchitectureScoreExplanation"] = Processor.process_getArchitectureScoreExplanation
        self._processMap["getPanelScoreExplanation"] = Processor.process_getPanelScoreExplanation
        self._processMap["getObjectiveScoreExplanation"] = Processor.process_getObjectiveScoreExplanation
        self._processMap["isGARunning"] = Processor.process_isGARunning
        self._processMap["stopGA"] = Processor.process_stopGA
        self._processMap["startGABinaryInput"] = Processor.process_startGABinaryInput
        self._processMap["startGADiscreteInput"] = Processor.process_startGADiscreteInput
        self._processMap["startGAScheduling"] = Processor.process_startGAScheduling
        self._processMap["getArchScienceInformationBinaryInput"] = Processor.process_getArchScienceInformationBinaryInput
        self._processMap["getArchCostInformationBinaryInput"] = Processor.process_getArchCostInformationBinaryInput
        self._processMap["getSubscoreDetailsBinaryInput"] = Processor.process_getSubscoreDetailsBinaryInput
        self._processMap["getArchScienceInformationDiscreteInput"] = Processor.process_getArchScienceInformationDiscreteInput
        self._processMap["getArchCostInformationDiscreteInput"] = Processor.process_getArchCostInformationDiscreteInput
        self._processMap["getSubscoreDetailsDiscreteInput"] = Processor.process_getSubscoreDetailsDiscreteInput
        self._processMap["getCommonMeasurements"] = Processor.process_getCommonMeasurements
        self._processMap["getMeasurements"] = Processor.process_getMeasurements
        self._processMap["getPanelScoresForArch"] = Processor.process_getPanelScoresForArch
        self._processMap["evaluateDataContinuityScore"] = Processor.process_evaluateDataContinuityScore
        self._processMap["evaluateFairnessScore"] = Processor.process_evaluateFairnessScore
        self._processMap["enumeratedDesigns"] = Processor.process_enumeratedDesigns

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_ping(self, seqid, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        try:
            self._handler.ping()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_evalBinaryInputArch(self, seqid, iprot, oprot):
        args = evalBinaryInputArch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = evalBinaryInputArch_result()
        try:
            result.success = self._handler.evalBinaryInputArch(args.problem, args.inputs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("evalBinaryInputArch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_evalDiscreteInputArch(self, seqid, iprot, oprot):
        args = evalDiscreteInputArch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = evalDiscreteInputArch_result()
        try:
            result.success = self._handler.evalDiscreteInputArch(args.problem, args.inputs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("evalDiscreteInputArch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runLocalSearchBinaryInput(self, seqid, iprot, oprot):
        args = runLocalSearchBinaryInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runLocalSearchBinaryInput_result()
        try:
            result.success = self._handler.runLocalSearchBinaryInput(args.problem, args.arch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runLocalSearchBinaryInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runLocalSearchDiscreteInput(self, seqid, iprot, oprot):
        args = runLocalSearchDiscreteInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runLocalSearchDiscreteInput_result()
        try:
            result.success = self._handler.runLocalSearchDiscreteInput(args.problem, args.arch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runLocalSearchDiscreteInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getOrbitList(self, seqid, iprot, oprot):
        args = getOrbitList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getOrbitList_result()
        try:
            result.success = self._handler.getOrbitList(args.problem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getOrbitList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getInstrumentList(self, seqid, iprot, oprot):
        args = getInstrumentList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getInstrumentList_result()
        try:
            result.success = self._handler.getInstrumentList(args.problem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getInstrumentList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getObjectiveList(self, seqid, iprot, oprot):
        args = getObjectiveList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getObjectiveList_result()
        try:
            result.success = self._handler.getObjectiveList(args.problem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getObjectiveList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSubobjectiveList(self, seqid, iprot, oprot):
        args = getSubobjectiveList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSubobjectiveList_result()
        try:
            result.success = self._handler.getSubobjectiveList(args.problem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSubobjectiveList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getInstrumentsForObjective(self, seqid, iprot, oprot):
        args = getInstrumentsForObjective_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getInstrumentsForObjective_result()
        try:
            result.success = self._handler.getInstrumentsForObjective(args.problem, args.objective)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getInstrumentsForObjective", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getInstrumentsForPanel(self, seqid, iprot, oprot):
        args = getInstrumentsForPanel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getInstrumentsForPanel_result()
        try:
            result.success = self._handler.getInstrumentsForPanel(args.problem, args.panel)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getInstrumentsForPanel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCritiqueBinaryInputArch(self, seqid, iprot, oprot):
        args = getCritiqueBinaryInputArch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCritiqueBinaryInputArch_result()
        try:
            result.success = self._handler.getCritiqueBinaryInputArch(args.problem, args.inputs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCritiqueBinaryInputArch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCritiqueDiscreteInputArch(self, seqid, iprot, oprot):
        args = getCritiqueDiscreteInputArch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCritiqueDiscreteInputArch_result()
        try:
            result.success = self._handler.getCritiqueDiscreteInputArch(args.problem, args.inputs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCritiqueDiscreteInputArch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getArchitectureScoreExplanation(self, seqid, iprot, oprot):
        args = getArchitectureScoreExplanation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getArchitectureScoreExplanation_result()
        try:
            result.success = self._handler.getArchitectureScoreExplanation(args.problem, args.arch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getArchitectureScoreExplanation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getPanelScoreExplanation(self, seqid, iprot, oprot):
        args = getPanelScoreExplanation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPanelScoreExplanation_result()
        try:
            result.success = self._handler.getPanelScoreExplanation(args.problem, args.arch, args.panel)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPanelScoreExplanation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getObjectiveScoreExplanation(self, seqid, iprot, oprot):
        args = getObjectiveScoreExplanation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getObjectiveScoreExplanation_result()
        try:
            result.success = self._handler.getObjectiveScoreExplanation(args.problem, args.arch, args.objective)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getObjectiveScoreExplanation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isGARunning(self, seqid, iprot, oprot):
        args = isGARunning_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isGARunning_result()
        try:
            result.success = self._handler.isGARunning(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isGARunning", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stopGA(self, seqid, iprot, oprot):
        args = stopGA_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stopGA_result()
        try:
            result.success = self._handler.stopGA(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stopGA", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_startGABinaryInput(self, seqid, iprot, oprot):
        args = startGABinaryInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startGABinaryInput_result()
        try:
            result.success = self._handler.startGABinaryInput(args.problem, args.dataset, args.username)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("startGABinaryInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_startGADiscreteInput(self, seqid, iprot, oprot):
        args = startGADiscreteInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startGADiscreteInput_result()
        try:
            result.success = self._handler.startGADiscreteInput(args.problem, args.dataset, args.username)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("startGADiscreteInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_startGAScheduling(self, seqid, iprot, oprot):
        args = startGAScheduling_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startGAScheduling_result()
        try:
            result.success = self._handler.startGAScheduling(args.problem, args.dataset, args.inputArches, args.historicalInfo, args.username)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("startGAScheduling", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getArchScienceInformationBinaryInput(self, seqid, iprot, oprot):
        args = getArchScienceInformationBinaryInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getArchScienceInformationBinaryInput_result()
        try:
            result.success = self._handler.getArchScienceInformationBinaryInput(args.problem, args.arch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getArchScienceInformationBinaryInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getArchCostInformationBinaryInput(self, seqid, iprot, oprot):
        args = getArchCostInformationBinaryInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getArchCostInformationBinaryInput_result()
        try:
            result.success = self._handler.getArchCostInformationBinaryInput(args.problem, args.arch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getArchCostInformationBinaryInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSubscoreDetailsBinaryInput(self, seqid, iprot, oprot):
        args = getSubscoreDetailsBinaryInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSubscoreDetailsBinaryInput_result()
        try:
            result.success = self._handler.getSubscoreDetailsBinaryInput(args.problem, args.arch, args.subobj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSubscoreDetailsBinaryInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getArchScienceInformationDiscreteInput(self, seqid, iprot, oprot):
        args = getArchScienceInformationDiscreteInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getArchScienceInformationDiscreteInput_result()
        try:
            result.success = self._handler.getArchScienceInformationDiscreteInput(args.problem, args.arch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getArchScienceInformationDiscreteInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getArchCostInformationDiscreteInput(self, seqid, iprot, oprot):
        args = getArchCostInformationDiscreteInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getArchCostInformationDiscreteInput_result()
        try:
            result.success = self._handler.getArchCostInformationDiscreteInput(args.problem, args.arch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getArchCostInformationDiscreteInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSubscoreDetailsDiscreteInput(self, seqid, iprot, oprot):
        args = getSubscoreDetailsDiscreteInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSubscoreDetailsDiscreteInput_result()
        try:
            result.success = self._handler.getSubscoreDetailsDiscreteInput(args.problem, args.arch, args.subobj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSubscoreDetailsDiscreteInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCommonMeasurements(self, seqid, iprot, oprot):
        args = getCommonMeasurements_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCommonMeasurements_result()
        try:
            result.success = self._handler.getCommonMeasurements(args.problem, args.arch_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCommonMeasurements", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMeasurements(self, seqid, iprot, oprot):
        args = getMeasurements_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMeasurements_result()
        try:
            result.success = self._handler.getMeasurements(args.problem, args.arch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMeasurements", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getPanelScoresForArch(self, seqid, iprot, oprot):
        args = getPanelScoresForArch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPanelScoresForArch_result()
        try:
            result.success = self._handler.getPanelScoresForArch(args.problem, args.arch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPanelScoresForArch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_evaluateDataContinuityScore(self, seqid, iprot, oprot):
        args = evaluateDataContinuityScore_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = evaluateDataContinuityScore_result()
        try:
            result.success = self._handler.evaluateDataContinuityScore(args.missionMeasurements, args.historical_missionMeasurements)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("evaluateDataContinuityScore", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_evaluateFairnessScore(self, seqid, iprot, oprot):
        args = evaluateFairnessScore_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = evaluateFairnessScore_result()
        try:
            result.success = self._handler.evaluateFairnessScore(args.missionMeasurements)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("evaluateFairnessScore", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enumeratedDesigns(self, seqid, iprot, oprot):
        args = enumeratedDesigns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enumeratedDesigns_result()
        try:
            result.success = self._handler.enumeratedDesigns(args.problem, args.input_arches, args.historical_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enumeratedDesigns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class ping_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_args)
ping_args.thrift_spec = (
)


class ping_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_result)
ping_result.thrift_spec = (
)


class evalBinaryInputArch_args(object):
    """
    Attributes:
     - problem
     - inputs

    """


    def __init__(self, problem=None, inputs=None,):
        self.problem = problem
        self.inputs = inputs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.inputs = []
                    (_etype149, _size146) = iprot.readListBegin()
                    for _i150 in range(_size146):
                        _elem151 = iprot.readBool()
                        self.inputs.append(_elem151)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('evalBinaryInputArch_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.inputs is not None:
            oprot.writeFieldBegin('inputs', TType.LIST, 2)
            oprot.writeListBegin(TType.BOOL, len(self.inputs))
            for iter152 in self.inputs:
                oprot.writeBool(iter152)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(evalBinaryInputArch_args)
evalBinaryInputArch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'inputs', (TType.BOOL, None, False), None, ),  # 2
)


class evalBinaryInputArch_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = BinaryInputArchitecture()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('evalBinaryInputArch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(evalBinaryInputArch_result)
evalBinaryInputArch_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [BinaryInputArchitecture, None], None, ),  # 0
)


class evalDiscreteInputArch_args(object):
    """
    Attributes:
     - problem
     - inputs

    """


    def __init__(self, problem=None, inputs=None,):
        self.problem = problem
        self.inputs = inputs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.inputs = []
                    (_etype156, _size153) = iprot.readListBegin()
                    for _i157 in range(_size153):
                        _elem158 = iprot.readI32()
                        self.inputs.append(_elem158)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('evalDiscreteInputArch_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.inputs is not None:
            oprot.writeFieldBegin('inputs', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.inputs))
            for iter159 in self.inputs:
                oprot.writeI32(iter159)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(evalDiscreteInputArch_args)
evalDiscreteInputArch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'inputs', (TType.I32, None, False), None, ),  # 2
)


class evalDiscreteInputArch_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DiscreteInputArchitecture()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('evalDiscreteInputArch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(evalDiscreteInputArch_result)
evalDiscreteInputArch_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [DiscreteInputArchitecture, None], None, ),  # 0
)


class runLocalSearchBinaryInput_args(object):
    """
    Attributes:
     - problem
     - arch

    """


    def __init__(self, problem=None, arch=None,):
        self.problem = problem
        self.arch = arch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runLocalSearchBinaryInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runLocalSearchBinaryInput_args)
runLocalSearchBinaryInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
)


class runLocalSearchBinaryInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype163, _size160) = iprot.readListBegin()
                    for _i164 in range(_size160):
                        _elem165 = BinaryInputArchitecture()
                        _elem165.read(iprot)
                        self.success.append(_elem165)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runLocalSearchBinaryInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter166 in self.success:
                iter166.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runLocalSearchBinaryInput_result)
runLocalSearchBinaryInput_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 0
)


class runLocalSearchDiscreteInput_args(object):
    """
    Attributes:
     - problem
     - arch

    """


    def __init__(self, problem=None, arch=None,):
        self.problem = problem
        self.arch = arch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = DiscreteInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runLocalSearchDiscreteInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runLocalSearchDiscreteInput_args)
runLocalSearchDiscreteInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [DiscreteInputArchitecture, None], None, ),  # 2
)


class runLocalSearchDiscreteInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype170, _size167) = iprot.readListBegin()
                    for _i171 in range(_size167):
                        _elem172 = DiscreteInputArchitecture()
                        _elem172.read(iprot)
                        self.success.append(_elem172)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runLocalSearchDiscreteInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter173 in self.success:
                iter173.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runLocalSearchDiscreteInput_result)
runLocalSearchDiscreteInput_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 0
)


class getOrbitList_args(object):
    """
    Attributes:
     - problem

    """


    def __init__(self, problem=None,):
        self.problem = problem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getOrbitList_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getOrbitList_args)
getOrbitList_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
)


class getOrbitList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype177, _size174) = iprot.readListBegin()
                    for _i178 in range(_size174):
                        _elem179 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem179)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getOrbitList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter180 in self.success:
                oprot.writeString(iter180.encode('utf-8') if sys.version_info[0] == 2 else iter180)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getOrbitList_result)
getOrbitList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class getInstrumentList_args(object):
    """
    Attributes:
     - problem

    """


    def __init__(self, problem=None,):
        self.problem = problem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getInstrumentList_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getInstrumentList_args)
getInstrumentList_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
)


class getInstrumentList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype184, _size181) = iprot.readListBegin()
                    for _i185 in range(_size181):
                        _elem186 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem186)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getInstrumentList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter187 in self.success:
                oprot.writeString(iter187.encode('utf-8') if sys.version_info[0] == 2 else iter187)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getInstrumentList_result)
getInstrumentList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class getObjectiveList_args(object):
    """
    Attributes:
     - problem

    """


    def __init__(self, problem=None,):
        self.problem = problem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getObjectiveList_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getObjectiveList_args)
getObjectiveList_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
)


class getObjectiveList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype191, _size188) = iprot.readListBegin()
                    for _i192 in range(_size188):
                        _elem193 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getObjectiveList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter194 in self.success:
                oprot.writeString(iter194.encode('utf-8') if sys.version_info[0] == 2 else iter194)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getObjectiveList_result)
getObjectiveList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class getSubobjectiveList_args(object):
    """
    Attributes:
     - problem

    """


    def __init__(self, problem=None,):
        self.problem = problem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSubobjectiveList_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSubobjectiveList_args)
getSubobjectiveList_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
)


class getSubobjectiveList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype198, _size195) = iprot.readListBegin()
                    for _i199 in range(_size195):
                        _elem200 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem200)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSubobjectiveList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter201 in self.success:
                oprot.writeString(iter201.encode('utf-8') if sys.version_info[0] == 2 else iter201)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSubobjectiveList_result)
getSubobjectiveList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class getInstrumentsForObjective_args(object):
    """
    Attributes:
     - problem
     - objective

    """


    def __init__(self, problem=None, objective=None,):
        self.problem = problem
        self.objective = objective

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.objective = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getInstrumentsForObjective_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.objective is not None:
            oprot.writeFieldBegin('objective', TType.STRING, 2)
            oprot.writeString(self.objective.encode('utf-8') if sys.version_info[0] == 2 else self.objective)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getInstrumentsForObjective_args)
getInstrumentsForObjective_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'objective', 'UTF8', None, ),  # 2
)


class getInstrumentsForObjective_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype205, _size202) = iprot.readListBegin()
                    for _i206 in range(_size202):
                        _elem207 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem207)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getInstrumentsForObjective_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter208 in self.success:
                oprot.writeString(iter208.encode('utf-8') if sys.version_info[0] == 2 else iter208)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getInstrumentsForObjective_result)
getInstrumentsForObjective_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class getInstrumentsForPanel_args(object):
    """
    Attributes:
     - problem
     - panel

    """


    def __init__(self, problem=None, panel=None,):
        self.problem = problem
        self.panel = panel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.panel = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getInstrumentsForPanel_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.panel is not None:
            oprot.writeFieldBegin('panel', TType.STRING, 2)
            oprot.writeString(self.panel.encode('utf-8') if sys.version_info[0] == 2 else self.panel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getInstrumentsForPanel_args)
getInstrumentsForPanel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'panel', 'UTF8', None, ),  # 2
)


class getInstrumentsForPanel_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype212, _size209) = iprot.readListBegin()
                    for _i213 in range(_size209):
                        _elem214 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem214)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getInstrumentsForPanel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter215 in self.success:
                oprot.writeString(iter215.encode('utf-8') if sys.version_info[0] == 2 else iter215)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getInstrumentsForPanel_result)
getInstrumentsForPanel_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class getCritiqueBinaryInputArch_args(object):
    """
    Attributes:
     - problem
     - inputs

    """


    def __init__(self, problem=None, inputs=None,):
        self.problem = problem
        self.inputs = inputs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.inputs = BinaryInputArchitecture()
                    self.inputs.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCritiqueBinaryInputArch_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.inputs is not None:
            oprot.writeFieldBegin('inputs', TType.STRUCT, 2)
            self.inputs.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCritiqueBinaryInputArch_args)
getCritiqueBinaryInputArch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'inputs', [BinaryInputArchitecture, None], None, ),  # 2
)


class getCritiqueBinaryInputArch_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype219, _size216) = iprot.readListBegin()
                    for _i220 in range(_size216):
                        _elem221 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem221)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCritiqueBinaryInputArch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter222 in self.success:
                oprot.writeString(iter222.encode('utf-8') if sys.version_info[0] == 2 else iter222)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCritiqueBinaryInputArch_result)
getCritiqueBinaryInputArch_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class getCritiqueDiscreteInputArch_args(object):
    """
    Attributes:
     - problem
     - inputs

    """


    def __init__(self, problem=None, inputs=None,):
        self.problem = problem
        self.inputs = inputs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.inputs = DiscreteInputArchitecture()
                    self.inputs.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCritiqueDiscreteInputArch_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.inputs is not None:
            oprot.writeFieldBegin('inputs', TType.STRUCT, 2)
            self.inputs.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCritiqueDiscreteInputArch_args)
getCritiqueDiscreteInputArch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'inputs', [DiscreteInputArchitecture, None], None, ),  # 2
)


class getCritiqueDiscreteInputArch_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype226, _size223) = iprot.readListBegin()
                    for _i227 in range(_size223):
                        _elem228 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem228)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCritiqueDiscreteInputArch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter229 in self.success:
                oprot.writeString(iter229.encode('utf-8') if sys.version_info[0] == 2 else iter229)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCritiqueDiscreteInputArch_result)
getCritiqueDiscreteInputArch_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class getArchitectureScoreExplanation_args(object):
    """
    Attributes:
     - problem
     - arch

    """


    def __init__(self, problem=None, arch=None,):
        self.problem = problem
        self.arch = arch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getArchitectureScoreExplanation_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getArchitectureScoreExplanation_args)
getArchitectureScoreExplanation_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
)


class getArchitectureScoreExplanation_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype233, _size230) = iprot.readListBegin()
                    for _i234 in range(_size230):
                        _elem235 = ObjectiveSatisfaction()
                        _elem235.read(iprot)
                        self.success.append(_elem235)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getArchitectureScoreExplanation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter236 in self.success:
                iter236.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getArchitectureScoreExplanation_result)
getArchitectureScoreExplanation_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ObjectiveSatisfaction, None], False), None, ),  # 0
)


class getPanelScoreExplanation_args(object):
    """
    Attributes:
     - problem
     - arch
     - panel

    """


    def __init__(self, problem=None, arch=None, panel=None,):
        self.problem = problem
        self.arch = arch
        self.panel = panel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.panel = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPanelScoreExplanation_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        if self.panel is not None:
            oprot.writeFieldBegin('panel', TType.STRING, 3)
            oprot.writeString(self.panel.encode('utf-8') if sys.version_info[0] == 2 else self.panel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPanelScoreExplanation_args)
getPanelScoreExplanation_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
    (3, TType.STRING, 'panel', 'UTF8', None, ),  # 3
)


class getPanelScoreExplanation_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype240, _size237) = iprot.readListBegin()
                    for _i241 in range(_size237):
                        _elem242 = ObjectiveSatisfaction()
                        _elem242.read(iprot)
                        self.success.append(_elem242)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPanelScoreExplanation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter243 in self.success:
                iter243.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPanelScoreExplanation_result)
getPanelScoreExplanation_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ObjectiveSatisfaction, None], False), None, ),  # 0
)


class getObjectiveScoreExplanation_args(object):
    """
    Attributes:
     - problem
     - arch
     - objective

    """


    def __init__(self, problem=None, arch=None, objective=None,):
        self.problem = problem
        self.arch = arch
        self.objective = objective

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.objective = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getObjectiveScoreExplanation_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        if self.objective is not None:
            oprot.writeFieldBegin('objective', TType.STRING, 3)
            oprot.writeString(self.objective.encode('utf-8') if sys.version_info[0] == 2 else self.objective)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getObjectiveScoreExplanation_args)
getObjectiveScoreExplanation_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
    (3, TType.STRING, 'objective', 'UTF8', None, ),  # 3
)


class getObjectiveScoreExplanation_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype247, _size244) = iprot.readListBegin()
                    for _i248 in range(_size244):
                        _elem249 = ObjectiveSatisfaction()
                        _elem249.read(iprot)
                        self.success.append(_elem249)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getObjectiveScoreExplanation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter250 in self.success:
                iter250.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getObjectiveScoreExplanation_result)
getObjectiveScoreExplanation_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ObjectiveSatisfaction, None], False), None, ),  # 0
)


class isGARunning_args(object):
    """
    Attributes:
     - id

    """


    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isGARunning_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isGARunning_args)
isGARunning_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
)


class isGARunning_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isGARunning_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isGARunning_result)
isGARunning_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class stopGA_args(object):
    """
    Attributes:
     - id

    """


    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopGA_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopGA_args)
stopGA_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
)


class stopGA_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopGA_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopGA_result)
stopGA_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class startGABinaryInput_args(object):
    """
    Attributes:
     - problem
     - dataset
     - username

    """


    def __init__(self, problem=None, dataset=None, username=None,):
        self.problem = problem
        self.dataset = dataset
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataset = []
                    (_etype254, _size251) = iprot.readListBegin()
                    for _i255 in range(_size251):
                        _elem256 = BinaryInputArchitecture()
                        _elem256.read(iprot)
                        self.dataset.append(_elem256)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startGABinaryInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.dataset is not None:
            oprot.writeFieldBegin('dataset', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataset))
            for iter257 in self.dataset:
                iter257.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 3)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startGABinaryInput_args)
startGABinaryInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'dataset', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 2
    (3, TType.STRING, 'username', 'UTF8', None, ),  # 3
)


class startGABinaryInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startGABinaryInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startGABinaryInput_result)
startGABinaryInput_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class startGADiscreteInput_args(object):
    """
    Attributes:
     - problem
     - dataset
     - username

    """


    def __init__(self, problem=None, dataset=None, username=None,):
        self.problem = problem
        self.dataset = dataset
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataset = []
                    (_etype261, _size258) = iprot.readListBegin()
                    for _i262 in range(_size258):
                        _elem263 = DiscreteInputArchitecture()
                        _elem263.read(iprot)
                        self.dataset.append(_elem263)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startGADiscreteInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.dataset is not None:
            oprot.writeFieldBegin('dataset', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataset))
            for iter264 in self.dataset:
                iter264.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 3)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startGADiscreteInput_args)
startGADiscreteInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'dataset', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 2
    (3, TType.STRING, 'username', 'UTF8', None, ),  # 3
)


class startGADiscreteInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startGADiscreteInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startGADiscreteInput_result)
startGADiscreteInput_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class startGAScheduling_args(object):
    """
    Attributes:
     - problem
     - dataset
     - inputArches
     - historicalInfo
     - username

    """


    def __init__(self, problem=None, dataset=None, inputArches=None, historicalInfo=None, username=None,):
        self.problem = problem
        self.dataset = dataset
        self.inputArches = inputArches
        self.historicalInfo = historicalInfo
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataset = []
                    (_etype268, _size265) = iprot.readListBegin()
                    for _i269 in range(_size265):
                        _elem270 = SchedulingInputArchitecture()
                        _elem270.read(iprot)
                        self.dataset.append(_elem270)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.inputArches = []
                    (_etype274, _size271) = iprot.readListBegin()
                    for _i275 in range(_size271):
                        _elem276 = BinaryInputArchitecture()
                        _elem276.read(iprot)
                        self.inputArches.append(_elem276)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.historicalInfo = []
                    (_etype280, _size277) = iprot.readListBegin()
                    for _i281 in range(_size277):
                        _elem282 = MissionMeasurements()
                        _elem282.read(iprot)
                        self.historicalInfo.append(_elem282)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startGAScheduling_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.dataset is not None:
            oprot.writeFieldBegin('dataset', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataset))
            for iter283 in self.dataset:
                iter283.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.inputArches is not None:
            oprot.writeFieldBegin('inputArches', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.inputArches))
            for iter284 in self.inputArches:
                iter284.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.historicalInfo is not None:
            oprot.writeFieldBegin('historicalInfo', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.historicalInfo))
            for iter285 in self.historicalInfo:
                iter285.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 5)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startGAScheduling_args)
startGAScheduling_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'dataset', (TType.STRUCT, [SchedulingInputArchitecture, None], False), None, ),  # 2
    (3, TType.LIST, 'inputArches', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 3
    (4, TType.LIST, 'historicalInfo', (TType.STRUCT, [MissionMeasurements, None], False), None, ),  # 4
    (5, TType.STRING, 'username', 'UTF8', None, ),  # 5
)


class startGAScheduling_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startGAScheduling_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startGAScheduling_result)
startGAScheduling_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getArchScienceInformationBinaryInput_args(object):
    """
    Attributes:
     - problem
     - arch

    """


    def __init__(self, problem=None, arch=None,):
        self.problem = problem
        self.arch = arch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getArchScienceInformationBinaryInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getArchScienceInformationBinaryInput_args)
getArchScienceInformationBinaryInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
)


class getArchScienceInformationBinaryInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype289, _size286) = iprot.readListBegin()
                    for _i290 in range(_size286):
                        _elem291 = SubscoreInformation()
                        _elem291.read(iprot)
                        self.success.append(_elem291)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getArchScienceInformationBinaryInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter292 in self.success:
                iter292.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getArchScienceInformationBinaryInput_result)
getArchScienceInformationBinaryInput_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [SubscoreInformation, None], False), None, ),  # 0
)


class getArchCostInformationBinaryInput_args(object):
    """
    Attributes:
     - problem
     - arch

    """


    def __init__(self, problem=None, arch=None,):
        self.problem = problem
        self.arch = arch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getArchCostInformationBinaryInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getArchCostInformationBinaryInput_args)
getArchCostInformationBinaryInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
)


class getArchCostInformationBinaryInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype296, _size293) = iprot.readListBegin()
                    for _i297 in range(_size293):
                        _elem298 = MissionCostInformation()
                        _elem298.read(iprot)
                        self.success.append(_elem298)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getArchCostInformationBinaryInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter299 in self.success:
                iter299.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getArchCostInformationBinaryInput_result)
getArchCostInformationBinaryInput_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [MissionCostInformation, None], False), None, ),  # 0
)


class getSubscoreDetailsBinaryInput_args(object):
    """
    Attributes:
     - problem
     - arch
     - subobj

    """


    def __init__(self, problem=None, arch=None, subobj=None,):
        self.problem = problem
        self.arch = arch
        self.subobj = subobj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.subobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSubscoreDetailsBinaryInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        if self.subobj is not None:
            oprot.writeFieldBegin('subobj', TType.STRING, 3)
            oprot.writeString(self.subobj.encode('utf-8') if sys.version_info[0] == 2 else self.subobj)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSubscoreDetailsBinaryInput_args)
getSubscoreDetailsBinaryInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
    (3, TType.STRING, 'subobj', 'UTF8', None, ),  # 3
)


class getSubscoreDetailsBinaryInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SubobjectiveDetails()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSubscoreDetailsBinaryInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSubscoreDetailsBinaryInput_result)
getSubscoreDetailsBinaryInput_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SubobjectiveDetails, None], None, ),  # 0
)


class getArchScienceInformationDiscreteInput_args(object):
    """
    Attributes:
     - problem
     - arch

    """


    def __init__(self, problem=None, arch=None,):
        self.problem = problem
        self.arch = arch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = DiscreteInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getArchScienceInformationDiscreteInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getArchScienceInformationDiscreteInput_args)
getArchScienceInformationDiscreteInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [DiscreteInputArchitecture, None], None, ),  # 2
)


class getArchScienceInformationDiscreteInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype303, _size300) = iprot.readListBegin()
                    for _i304 in range(_size300):
                        _elem305 = SubscoreInformation()
                        _elem305.read(iprot)
                        self.success.append(_elem305)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getArchScienceInformationDiscreteInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter306 in self.success:
                iter306.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getArchScienceInformationDiscreteInput_result)
getArchScienceInformationDiscreteInput_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [SubscoreInformation, None], False), None, ),  # 0
)


class getArchCostInformationDiscreteInput_args(object):
    """
    Attributes:
     - problem
     - arch

    """


    def __init__(self, problem=None, arch=None,):
        self.problem = problem
        self.arch = arch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = DiscreteInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getArchCostInformationDiscreteInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getArchCostInformationDiscreteInput_args)
getArchCostInformationDiscreteInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [DiscreteInputArchitecture, None], None, ),  # 2
)


class getArchCostInformationDiscreteInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype310, _size307) = iprot.readListBegin()
                    for _i311 in range(_size307):
                        _elem312 = MissionCostInformation()
                        _elem312.read(iprot)
                        self.success.append(_elem312)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getArchCostInformationDiscreteInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter313 in self.success:
                iter313.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getArchCostInformationDiscreteInput_result)
getArchCostInformationDiscreteInput_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [MissionCostInformation, None], False), None, ),  # 0
)


class getSubscoreDetailsDiscreteInput_args(object):
    """
    Attributes:
     - problem
     - arch
     - subobj

    """


    def __init__(self, problem=None, arch=None, subobj=None,):
        self.problem = problem
        self.arch = arch
        self.subobj = subobj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = DiscreteInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.subobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSubscoreDetailsDiscreteInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        if self.subobj is not None:
            oprot.writeFieldBegin('subobj', TType.STRING, 3)
            oprot.writeString(self.subobj.encode('utf-8') if sys.version_info[0] == 2 else self.subobj)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSubscoreDetailsDiscreteInput_args)
getSubscoreDetailsDiscreteInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [DiscreteInputArchitecture, None], None, ),  # 2
    (3, TType.STRING, 'subobj', 'UTF8', None, ),  # 3
)


class getSubscoreDetailsDiscreteInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SubobjectiveDetails()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSubscoreDetailsDiscreteInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSubscoreDetailsDiscreteInput_result)
getSubscoreDetailsDiscreteInput_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SubobjectiveDetails, None], None, ),  # 0
)


class getCommonMeasurements_args(object):
    """
    Attributes:
     - problem
     - arch_list

    """


    def __init__(self, problem=None, arch_list=None,):
        self.problem = problem
        self.arch_list = arch_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.arch_list = []
                    (_etype317, _size314) = iprot.readListBegin()
                    for _i318 in range(_size314):
                        _elem319 = BinaryInputArchitecture()
                        _elem319.read(iprot)
                        self.arch_list.append(_elem319)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCommonMeasurements_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch_list is not None:
            oprot.writeFieldBegin('arch_list', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.arch_list))
            for iter320 in self.arch_list:
                iter320.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCommonMeasurements_args)
getCommonMeasurements_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'arch_list', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 2
)


class getCommonMeasurements_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype324, _size321) = iprot.readListBegin()
                    for _i325 in range(_size321):
                        _elem326 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem326)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCommonMeasurements_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter327 in self.success:
                oprot.writeString(iter327.encode('utf-8') if sys.version_info[0] == 2 else iter327)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCommonMeasurements_result)
getCommonMeasurements_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class getMeasurements_args(object):
    """
    Attributes:
     - problem
     - arch

    """


    def __init__(self, problem=None, arch=None,):
        self.problem = problem
        self.arch = arch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMeasurements_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMeasurements_args)
getMeasurements_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
)


class getMeasurements_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype331, _size328) = iprot.readListBegin()
                    for _i332 in range(_size328):
                        _elem333 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem333)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMeasurements_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter334 in self.success:
                oprot.writeString(iter334.encode('utf-8') if sys.version_info[0] == 2 else iter334)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMeasurements_result)
getMeasurements_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class getPanelScoresForArch_args(object):
    """
    Attributes:
     - problem
     - arch

    """


    def __init__(self, problem=None, arch=None,):
        self.problem = problem
        self.arch = arch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPanelScoresForArch_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPanelScoresForArch_args)
getPanelScoresForArch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
)


class getPanelScoresForArch_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype338, _size335) = iprot.readListBegin()
                    for _i339 in range(_size335):
                        _elem340 = iprot.readDouble()
                        self.success.append(_elem340)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPanelScoresForArch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter341 in self.success:
                oprot.writeDouble(iter341)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPanelScoresForArch_result)
getPanelScoresForArch_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class evaluateDataContinuityScore_args(object):
    """
    Attributes:
     - missionMeasurements
     - historical_missionMeasurements

    """


    def __init__(self, missionMeasurements=None, historical_missionMeasurements=None,):
        self.missionMeasurements = missionMeasurements
        self.historical_missionMeasurements = historical_missionMeasurements

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.missionMeasurements = []
                    (_etype345, _size342) = iprot.readListBegin()
                    for _i346 in range(_size342):
                        _elem347 = MissionMeasurements()
                        _elem347.read(iprot)
                        self.missionMeasurements.append(_elem347)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.historical_missionMeasurements = []
                    (_etype351, _size348) = iprot.readListBegin()
                    for _i352 in range(_size348):
                        _elem353 = MissionMeasurements()
                        _elem353.read(iprot)
                        self.historical_missionMeasurements.append(_elem353)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('evaluateDataContinuityScore_args')
        if self.missionMeasurements is not None:
            oprot.writeFieldBegin('missionMeasurements', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.missionMeasurements))
            for iter354 in self.missionMeasurements:
                iter354.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.historical_missionMeasurements is not None:
            oprot.writeFieldBegin('historical_missionMeasurements', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.historical_missionMeasurements))
            for iter355 in self.historical_missionMeasurements:
                iter355.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(evaluateDataContinuityScore_args)
evaluateDataContinuityScore_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'missionMeasurements', (TType.STRUCT, [MissionMeasurements, None], False), None, ),  # 1
    (2, TType.LIST, 'historical_missionMeasurements', (TType.STRUCT, [MissionMeasurements, None], False), None, ),  # 2
)


class evaluateDataContinuityScore_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('evaluateDataContinuityScore_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(evaluateDataContinuityScore_result)
evaluateDataContinuityScore_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class evaluateFairnessScore_args(object):
    """
    Attributes:
     - missionMeasurements

    """


    def __init__(self, missionMeasurements=None,):
        self.missionMeasurements = missionMeasurements

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.missionMeasurements = []
                    (_etype359, _size356) = iprot.readListBegin()
                    for _i360 in range(_size356):
                        _elem361 = MissionMeasurements()
                        _elem361.read(iprot)
                        self.missionMeasurements.append(_elem361)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('evaluateFairnessScore_args')
        if self.missionMeasurements is not None:
            oprot.writeFieldBegin('missionMeasurements', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.missionMeasurements))
            for iter362 in self.missionMeasurements:
                iter362.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(evaluateFairnessScore_args)
evaluateFairnessScore_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'missionMeasurements', (TType.STRUCT, [MissionMeasurements, None], False), None, ),  # 1
)


class evaluateFairnessScore_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('evaluateFairnessScore_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(evaluateFairnessScore_result)
evaluateFairnessScore_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class enumeratedDesigns_args(object):
    """
    Attributes:
     - problem
     - input_arches
     - historical_info

    """


    def __init__(self, problem=None, input_arches=None, historical_info=None,):
        self.problem = problem
        self.input_arches = input_arches
        self.historical_info = historical_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.input_arches = []
                    (_etype366, _size363) = iprot.readListBegin()
                    for _i367 in range(_size363):
                        _elem368 = BinaryInputArchitecture()
                        _elem368.read(iprot)
                        self.input_arches.append(_elem368)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.historical_info = []
                    (_etype372, _size369) = iprot.readListBegin()
                    for _i373 in range(_size369):
                        _elem374 = MissionMeasurements()
                        _elem374.read(iprot)
                        self.historical_info.append(_elem374)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enumeratedDesigns_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.input_arches is not None:
            oprot.writeFieldBegin('input_arches', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.input_arches))
            for iter375 in self.input_arches:
                iter375.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.historical_info is not None:
            oprot.writeFieldBegin('historical_info', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.historical_info))
            for iter376 in self.historical_info:
                iter376.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enumeratedDesigns_args)
enumeratedDesigns_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'input_arches', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 2
    (3, TType.LIST, 'historical_info', (TType.STRUCT, [MissionMeasurements, None], False), None, ),  # 3
)


class enumeratedDesigns_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enumeratedDesigns_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enumeratedDesigns_result)
enumeratedDesigns_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)
fix_spec(all_structs)
del all_structs

