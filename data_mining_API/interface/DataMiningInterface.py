#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def ping(self):
        pass

    def getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def getMarginalDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        pass

    def getDrivingFeaturesEpsilonMOEABinary(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def getMarginalDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        pass

    def getDrivingFeaturesEpsilonMOEADiscrete(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def getDrivingFeaturesContinuous(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def getDrivingFeaturesEpsilonMOEAContinuous(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def generalizeFeatureBinary(self, problem, session, behavioral, non_behavioral, all_archs, rootfeatureExpression, nodeFeatureExpression):
        """
        Parameters:
         - problem
         - session
         - behavioral
         - non_behavioral
         - all_archs
         - rootfeatureExpression
         - nodeFeatureExpression
        """
        pass

    def getDrivingFeaturesWithGeneralizationBinary(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def simplifyFeatureExpression(self, problem, expression):
        """
        Parameters:
         - problem
         - expression
        """
        pass

    def stopSearch(self, session):
        """
        Parameters:
         - session
        """
        pass

    def computeComplexityOfFeatures(self, problem, expressions):
        """
        Parameters:
         - problem
         - expressions
        """
        pass

    def computeAlgebraicTypicality(self, problem, arch, feature):
        """
        Parameters:
         - problem
         - arch
         - feature
        """
        pass

    def computeComplexity(self, problem, expression):
        """
        Parameters:
         - problem
         - expression
        """
        pass

    def convertToCNF(self, expression):
        """
        Parameters:
         - expression
        """
        pass

    def convertToDNF(self, expression):
        """
        Parameters:
         - expression
        """
        pass

    def setAssigningProblemEntities(self, problem, entities):
        """
        Parameters:
         - problem
         - entities
        """
        pass

    def setAssigningProblemGeneralizedConcepts(self, problem, generalizedConcepts):
        """
        Parameters:
         - problem
         - generalizedConcepts
        """
        pass

    def getAssigningProblemEntities(self, problem):
        """
        Parameters:
         - problem
        """
        pass

    def getAssigningProblemConceptHierarchy(self, problem, params):
        """
        Parameters:
         - problem
         - params
        """
        pass

    def computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        """
        Parameters:
         - problem
         - architecture
         - feature
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def ping(self):
        self.send_ping()
        self.recv_ping()

    def send_ping(self):
        self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
        args = ping_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_getDrivingFeaturesBinary(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_getDrivingFeaturesBinary()

    def send_getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('getDrivingFeaturesBinary', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesBinary failed: unknown result")

    def getMarginalDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        self.send_getMarginalDrivingFeaturesBinary(problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift)
        return self.recv_getMarginalDrivingFeaturesBinary()

    def send_getMarginalDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        self._oprot.writeMessageBegin('getMarginalDrivingFeaturesBinary', TMessageType.CALL, self._seqid)
        args = getMarginalDrivingFeaturesBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.featureExpression = featureExpression
        args.logical_connective = logical_connective
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMarginalDrivingFeaturesBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMarginalDrivingFeaturesBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMarginalDrivingFeaturesBinary failed: unknown result")

    def getDrivingFeaturesEpsilonMOEABinary(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesEpsilonMOEABinary(problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesEpsilonMOEABinary()

    def send_getDrivingFeaturesEpsilonMOEABinary(self, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesEpsilonMOEABinary', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesEpsilonMOEABinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesEpsilonMOEABinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesEpsilonMOEABinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesEpsilonMOEABinary failed: unknown result")

    def getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_getDrivingFeaturesDiscrete(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_getDrivingFeaturesDiscrete()

    def send_getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('getDrivingFeaturesDiscrete', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesDiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesDiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesDiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesDiscrete failed: unknown result")

    def getMarginalDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        self.send_getMarginalDrivingFeaturesDiscrete(problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift)
        return self.recv_getMarginalDrivingFeaturesDiscrete()

    def send_getMarginalDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        self._oprot.writeMessageBegin('getMarginalDrivingFeaturesDiscrete', TMessageType.CALL, self._seqid)
        args = getMarginalDrivingFeaturesDiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.featureExpression = featureExpression
        args.logical_connective = logical_connective
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMarginalDrivingFeaturesDiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMarginalDrivingFeaturesDiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMarginalDrivingFeaturesDiscrete failed: unknown result")

    def getDrivingFeaturesEpsilonMOEADiscrete(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesEpsilonMOEADiscrete(problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesEpsilonMOEADiscrete()

    def send_getDrivingFeaturesEpsilonMOEADiscrete(self, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesEpsilonMOEADiscrete', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesEpsilonMOEADiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesEpsilonMOEADiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesEpsilonMOEADiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesEpsilonMOEADiscrete failed: unknown result")

    def getDrivingFeaturesContinuous(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_getDrivingFeaturesContinuous(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_getDrivingFeaturesContinuous()

    def send_getDrivingFeaturesContinuous(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('getDrivingFeaturesContinuous', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesContinuous_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesContinuous(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesContinuous_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesContinuous failed: unknown result")

    def getDrivingFeaturesEpsilonMOEAContinuous(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesEpsilonMOEAContinuous(problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesEpsilonMOEAContinuous()

    def send_getDrivingFeaturesEpsilonMOEAContinuous(self, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesEpsilonMOEAContinuous', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesEpsilonMOEAContinuous_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesEpsilonMOEAContinuous(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesEpsilonMOEAContinuous_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesEpsilonMOEAContinuous failed: unknown result")

    def generalizeFeatureBinary(self, problem, session, behavioral, non_behavioral, all_archs, rootfeatureExpression, nodeFeatureExpression):
        """
        Parameters:
         - problem
         - session
         - behavioral
         - non_behavioral
         - all_archs
         - rootfeatureExpression
         - nodeFeatureExpression
        """
        self.send_generalizeFeatureBinary(problem, session, behavioral, non_behavioral, all_archs, rootfeatureExpression, nodeFeatureExpression)
        return self.recv_generalizeFeatureBinary()

    def send_generalizeFeatureBinary(self, problem, session, behavioral, non_behavioral, all_archs, rootfeatureExpression, nodeFeatureExpression):
        self._oprot.writeMessageBegin('generalizeFeatureBinary', TMessageType.CALL, self._seqid)
        args = generalizeFeatureBinary_args()
        args.problem = problem
        args.session = session
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.rootfeatureExpression = rootfeatureExpression
        args.nodeFeatureExpression = nodeFeatureExpression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_generalizeFeatureBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = generalizeFeatureBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "generalizeFeatureBinary failed: unknown result")

    def getDrivingFeaturesWithGeneralizationBinary(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesWithGeneralizationBinary(problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesWithGeneralizationBinary()

    def send_getDrivingFeaturesWithGeneralizationBinary(self, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesWithGeneralizationBinary', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesWithGeneralizationBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesWithGeneralizationBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesWithGeneralizationBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesWithGeneralizationBinary failed: unknown result")

    def simplifyFeatureExpression(self, problem, expression):
        """
        Parameters:
         - problem
         - expression
        """
        self.send_simplifyFeatureExpression(problem, expression)
        return self.recv_simplifyFeatureExpression()

    def send_simplifyFeatureExpression(self, problem, expression):
        self._oprot.writeMessageBegin('simplifyFeatureExpression', TMessageType.CALL, self._seqid)
        args = simplifyFeatureExpression_args()
        args.problem = problem
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_simplifyFeatureExpression(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = simplifyFeatureExpression_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "simplifyFeatureExpression failed: unknown result")

    def stopSearch(self, session):
        """
        Parameters:
         - session
        """
        self.send_stopSearch(session)
        return self.recv_stopSearch()

    def send_stopSearch(self, session):
        self._oprot.writeMessageBegin('stopSearch', TMessageType.CALL, self._seqid)
        args = stopSearch_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stopSearch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stopSearch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stopSearch failed: unknown result")

    def computeComplexityOfFeatures(self, problem, expressions):
        """
        Parameters:
         - problem
         - expressions
        """
        self.send_computeComplexityOfFeatures(problem, expressions)
        return self.recv_computeComplexityOfFeatures()

    def send_computeComplexityOfFeatures(self, problem, expressions):
        self._oprot.writeMessageBegin('computeComplexityOfFeatures', TMessageType.CALL, self._seqid)
        args = computeComplexityOfFeatures_args()
        args.problem = problem
        args.expressions = expressions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeComplexityOfFeatures(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeComplexityOfFeatures_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeComplexityOfFeatures failed: unknown result")

    def computeAlgebraicTypicality(self, problem, arch, feature):
        """
        Parameters:
         - problem
         - arch
         - feature
        """
        self.send_computeAlgebraicTypicality(problem, arch, feature)
        return self.recv_computeAlgebraicTypicality()

    def send_computeAlgebraicTypicality(self, problem, arch, feature):
        self._oprot.writeMessageBegin('computeAlgebraicTypicality', TMessageType.CALL, self._seqid)
        args = computeAlgebraicTypicality_args()
        args.problem = problem
        args.arch = arch
        args.feature = feature
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeAlgebraicTypicality(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeAlgebraicTypicality_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeAlgebraicTypicality failed: unknown result")

    def computeComplexity(self, problem, expression):
        """
        Parameters:
         - problem
         - expression
        """
        self.send_computeComplexity(problem, expression)
        return self.recv_computeComplexity()

    def send_computeComplexity(self, problem, expression):
        self._oprot.writeMessageBegin('computeComplexity', TMessageType.CALL, self._seqid)
        args = computeComplexity_args()
        args.problem = problem
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeComplexity(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeComplexity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeComplexity failed: unknown result")

    def convertToCNF(self, expression):
        """
        Parameters:
         - expression
        """
        self.send_convertToCNF(expression)
        return self.recv_convertToCNF()

    def send_convertToCNF(self, expression):
        self._oprot.writeMessageBegin('convertToCNF', TMessageType.CALL, self._seqid)
        args = convertToCNF_args()
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_convertToCNF(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = convertToCNF_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "convertToCNF failed: unknown result")

    def convertToDNF(self, expression):
        """
        Parameters:
         - expression
        """
        self.send_convertToDNF(expression)
        return self.recv_convertToDNF()

    def send_convertToDNF(self, expression):
        self._oprot.writeMessageBegin('convertToDNF', TMessageType.CALL, self._seqid)
        args = convertToDNF_args()
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_convertToDNF(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = convertToDNF_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "convertToDNF failed: unknown result")

    def setAssigningProblemEntities(self, problem, entities):
        """
        Parameters:
         - problem
         - entities
        """
        self.send_setAssigningProblemEntities(problem, entities)
        return self.recv_setAssigningProblemEntities()

    def send_setAssigningProblemEntities(self, problem, entities):
        self._oprot.writeMessageBegin('setAssigningProblemEntities', TMessageType.CALL, self._seqid)
        args = setAssigningProblemEntities_args()
        args.problem = problem
        args.entities = entities
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setAssigningProblemEntities(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setAssigningProblemEntities_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setAssigningProblemEntities failed: unknown result")

    def setAssigningProblemGeneralizedConcepts(self, problem, generalizedConcepts):
        """
        Parameters:
         - problem
         - generalizedConcepts
        """
        self.send_setAssigningProblemGeneralizedConcepts(problem, generalizedConcepts)
        return self.recv_setAssigningProblemGeneralizedConcepts()

    def send_setAssigningProblemGeneralizedConcepts(self, problem, generalizedConcepts):
        self._oprot.writeMessageBegin('setAssigningProblemGeneralizedConcepts', TMessageType.CALL, self._seqid)
        args = setAssigningProblemGeneralizedConcepts_args()
        args.problem = problem
        args.generalizedConcepts = generalizedConcepts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setAssigningProblemGeneralizedConcepts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setAssigningProblemGeneralizedConcepts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setAssigningProblemGeneralizedConcepts failed: unknown result")

    def getAssigningProblemEntities(self, problem):
        """
        Parameters:
         - problem
        """
        self.send_getAssigningProblemEntities(problem)
        return self.recv_getAssigningProblemEntities()

    def send_getAssigningProblemEntities(self, problem):
        self._oprot.writeMessageBegin('getAssigningProblemEntities', TMessageType.CALL, self._seqid)
        args = getAssigningProblemEntities_args()
        args.problem = problem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAssigningProblemEntities(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAssigningProblemEntities_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAssigningProblemEntities failed: unknown result")

    def getAssigningProblemConceptHierarchy(self, problem, params):
        """
        Parameters:
         - problem
         - params
        """
        self.send_getAssigningProblemConceptHierarchy(problem, params)
        return self.recv_getAssigningProblemConceptHierarchy()

    def send_getAssigningProblemConceptHierarchy(self, problem, params):
        self._oprot.writeMessageBegin('getAssigningProblemConceptHierarchy', TMessageType.CALL, self._seqid)
        args = getAssigningProblemConceptHierarchy_args()
        args.problem = problem
        args.params = params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAssigningProblemConceptHierarchy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAssigningProblemConceptHierarchy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAssigningProblemConceptHierarchy failed: unknown result")

    def computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        """
        Parameters:
         - problem
         - architecture
         - feature
        """
        self.send_computeAlgebraicTypicalityWithStringInput(problem, architecture, feature)
        return self.recv_computeAlgebraicTypicalityWithStringInput()

    def send_computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        self._oprot.writeMessageBegin('computeAlgebraicTypicalityWithStringInput', TMessageType.CALL, self._seqid)
        args = computeAlgebraicTypicalityWithStringInput_args()
        args.problem = problem
        args.architecture = architecture
        args.feature = feature
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeAlgebraicTypicalityWithStringInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeAlgebraicTypicalityWithStringInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeAlgebraicTypicalityWithStringInput failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["ping"] = Processor.process_ping
        self._processMap["getDrivingFeaturesBinary"] = Processor.process_getDrivingFeaturesBinary
        self._processMap["getMarginalDrivingFeaturesBinary"] = Processor.process_getMarginalDrivingFeaturesBinary
        self._processMap["getDrivingFeaturesEpsilonMOEABinary"] = Processor.process_getDrivingFeaturesEpsilonMOEABinary
        self._processMap["getDrivingFeaturesDiscrete"] = Processor.process_getDrivingFeaturesDiscrete
        self._processMap["getMarginalDrivingFeaturesDiscrete"] = Processor.process_getMarginalDrivingFeaturesDiscrete
        self._processMap["getDrivingFeaturesEpsilonMOEADiscrete"] = Processor.process_getDrivingFeaturesEpsilonMOEADiscrete
        self._processMap["getDrivingFeaturesContinuous"] = Processor.process_getDrivingFeaturesContinuous
        self._processMap["getDrivingFeaturesEpsilonMOEAContinuous"] = Processor.process_getDrivingFeaturesEpsilonMOEAContinuous
        self._processMap["generalizeFeatureBinary"] = Processor.process_generalizeFeatureBinary
        self._processMap["getDrivingFeaturesWithGeneralizationBinary"] = Processor.process_getDrivingFeaturesWithGeneralizationBinary
        self._processMap["simplifyFeatureExpression"] = Processor.process_simplifyFeatureExpression
        self._processMap["stopSearch"] = Processor.process_stopSearch
        self._processMap["computeComplexityOfFeatures"] = Processor.process_computeComplexityOfFeatures
        self._processMap["computeAlgebraicTypicality"] = Processor.process_computeAlgebraicTypicality
        self._processMap["computeComplexity"] = Processor.process_computeComplexity
        self._processMap["convertToCNF"] = Processor.process_convertToCNF
        self._processMap["convertToDNF"] = Processor.process_convertToDNF
        self._processMap["setAssigningProblemEntities"] = Processor.process_setAssigningProblemEntities
        self._processMap["setAssigningProblemGeneralizedConcepts"] = Processor.process_setAssigningProblemGeneralizedConcepts
        self._processMap["getAssigningProblemEntities"] = Processor.process_getAssigningProblemEntities
        self._processMap["getAssigningProblemConceptHierarchy"] = Processor.process_getAssigningProblemConceptHierarchy
        self._processMap["computeAlgebraicTypicalityWithStringInput"] = Processor.process_computeAlgebraicTypicalityWithStringInput

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_ping(self, seqid, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        try:
            self._handler.ping()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesBinary(self, seqid, iprot, oprot):
        args = getDrivingFeaturesBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesBinary_result()
        try:
            result.success = self._handler.getDrivingFeaturesBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMarginalDrivingFeaturesBinary(self, seqid, iprot, oprot):
        args = getMarginalDrivingFeaturesBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMarginalDrivingFeaturesBinary_result()
        try:
            result.success = self._handler.getMarginalDrivingFeaturesBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.featureExpression, args.logical_connective, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMarginalDrivingFeaturesBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesEpsilonMOEABinary(self, seqid, iprot, oprot):
        args = getDrivingFeaturesEpsilonMOEABinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesEpsilonMOEABinary_result()
        try:
            result.success = self._handler.getDrivingFeaturesEpsilonMOEABinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesEpsilonMOEABinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesDiscrete(self, seqid, iprot, oprot):
        args = getDrivingFeaturesDiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesDiscrete_result()
        try:
            result.success = self._handler.getDrivingFeaturesDiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesDiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMarginalDrivingFeaturesDiscrete(self, seqid, iprot, oprot):
        args = getMarginalDrivingFeaturesDiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMarginalDrivingFeaturesDiscrete_result()
        try:
            result.success = self._handler.getMarginalDrivingFeaturesDiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.featureExpression, args.logical_connective, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMarginalDrivingFeaturesDiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesEpsilonMOEADiscrete(self, seqid, iprot, oprot):
        args = getDrivingFeaturesEpsilonMOEADiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesEpsilonMOEADiscrete_result()
        try:
            result.success = self._handler.getDrivingFeaturesEpsilonMOEADiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesEpsilonMOEADiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesContinuous(self, seqid, iprot, oprot):
        args = getDrivingFeaturesContinuous_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesContinuous_result()
        try:
            result.success = self._handler.getDrivingFeaturesContinuous(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesContinuous", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesEpsilonMOEAContinuous(self, seqid, iprot, oprot):
        args = getDrivingFeaturesEpsilonMOEAContinuous_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesEpsilonMOEAContinuous_result()
        try:
            result.success = self._handler.getDrivingFeaturesEpsilonMOEAContinuous(args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesEpsilonMOEAContinuous", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_generalizeFeatureBinary(self, seqid, iprot, oprot):
        args = generalizeFeatureBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = generalizeFeatureBinary_result()
        try:
            result.success = self._handler.generalizeFeatureBinary(args.problem, args.session, args.behavioral, args.non_behavioral, args.all_archs, args.rootfeatureExpression, args.nodeFeatureExpression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("generalizeFeatureBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesWithGeneralizationBinary(self, seqid, iprot, oprot):
        args = getDrivingFeaturesWithGeneralizationBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesWithGeneralizationBinary_result()
        try:
            result.success = self._handler.getDrivingFeaturesWithGeneralizationBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesWithGeneralizationBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_simplifyFeatureExpression(self, seqid, iprot, oprot):
        args = simplifyFeatureExpression_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = simplifyFeatureExpression_result()
        try:
            result.success = self._handler.simplifyFeatureExpression(args.problem, args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("simplifyFeatureExpression", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stopSearch(self, seqid, iprot, oprot):
        args = stopSearch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stopSearch_result()
        try:
            result.success = self._handler.stopSearch(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stopSearch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeComplexityOfFeatures(self, seqid, iprot, oprot):
        args = computeComplexityOfFeatures_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeComplexityOfFeatures_result()
        try:
            result.success = self._handler.computeComplexityOfFeatures(args.problem, args.expressions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeComplexityOfFeatures", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeAlgebraicTypicality(self, seqid, iprot, oprot):
        args = computeAlgebraicTypicality_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeAlgebraicTypicality_result()
        try:
            result.success = self._handler.computeAlgebraicTypicality(args.problem, args.arch, args.feature)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeAlgebraicTypicality", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeComplexity(self, seqid, iprot, oprot):
        args = computeComplexity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeComplexity_result()
        try:
            result.success = self._handler.computeComplexity(args.problem, args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeComplexity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_convertToCNF(self, seqid, iprot, oprot):
        args = convertToCNF_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = convertToCNF_result()
        try:
            result.success = self._handler.convertToCNF(args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("convertToCNF", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_convertToDNF(self, seqid, iprot, oprot):
        args = convertToDNF_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = convertToDNF_result()
        try:
            result.success = self._handler.convertToDNF(args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("convertToDNF", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setAssigningProblemEntities(self, seqid, iprot, oprot):
        args = setAssigningProblemEntities_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setAssigningProblemEntities_result()
        try:
            result.success = self._handler.setAssigningProblemEntities(args.problem, args.entities)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setAssigningProblemEntities", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setAssigningProblemGeneralizedConcepts(self, seqid, iprot, oprot):
        args = setAssigningProblemGeneralizedConcepts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setAssigningProblemGeneralizedConcepts_result()
        try:
            result.success = self._handler.setAssigningProblemGeneralizedConcepts(args.problem, args.generalizedConcepts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setAssigningProblemGeneralizedConcepts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAssigningProblemEntities(self, seqid, iprot, oprot):
        args = getAssigningProblemEntities_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAssigningProblemEntities_result()
        try:
            result.success = self._handler.getAssigningProblemEntities(args.problem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAssigningProblemEntities", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAssigningProblemConceptHierarchy(self, seqid, iprot, oprot):
        args = getAssigningProblemConceptHierarchy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAssigningProblemConceptHierarchy_result()
        try:
            result.success = self._handler.getAssigningProblemConceptHierarchy(args.problem, args.params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAssigningProblemConceptHierarchy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeAlgebraicTypicalityWithStringInput(self, seqid, iprot, oprot):
        args = computeAlgebraicTypicalityWithStringInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeAlgebraicTypicalityWithStringInput_result()
        try:
            result.success = self._handler.computeAlgebraicTypicalityWithStringInput(args.problem, args.architecture, args.feature)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeAlgebraicTypicalityWithStringInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class ping_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_args)
ping_args.thrift_spec = (
)


class ping_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_result)
ping_result.thrift_spec = (
)


class getDrivingFeaturesBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype112, _size109) = iprot.readListBegin()
                    for _i113 in range(_size109):
                        _elem114 = iprot.readI32()
                        self.behavioral.append(_elem114)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype118, _size115) = iprot.readListBegin()
                    for _i119 in range(_size115):
                        _elem120 = iprot.readI32()
                        self.non_behavioral.append(_elem120)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = BinaryInputArchitecture()
                        _elem126.read(iprot)
                        self.all_archs.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter127 in self.behavioral:
                oprot.writeI32(iter127)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter128 in self.non_behavioral:
                oprot.writeI32(iter128)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter129 in self.all_archs:
                iter129.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesBinary_args)
getDrivingFeaturesBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class getDrivingFeaturesBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype133, _size130) = iprot.readListBegin()
                    for _i134 in range(_size130):
                        _elem135 = Feature()
                        _elem135.read(iprot)
                        self.success.append(_elem135)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter136 in self.success:
                iter136.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesBinary_result)
getDrivingFeaturesBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getMarginalDrivingFeaturesBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - featureExpression
     - logical_connective
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, featureExpression=None, logical_connective=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.featureExpression = featureExpression
        self.logical_connective = logical_connective
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype140, _size137) = iprot.readListBegin()
                    for _i141 in range(_size137):
                        _elem142 = iprot.readI32()
                        self.behavioral.append(_elem142)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype146, _size143) = iprot.readListBegin()
                    for _i147 in range(_size143):
                        _elem148 = iprot.readI32()
                        self.non_behavioral.append(_elem148)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype152, _size149) = iprot.readListBegin()
                    for _i153 in range(_size149):
                        _elem154 = BinaryInputArchitecture()
                        _elem154.read(iprot)
                        self.all_archs.append(_elem154)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.featureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.logical_connective = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter155 in self.behavioral:
                oprot.writeI32(iter155)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter156 in self.non_behavioral:
                oprot.writeI32(iter156)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter157 in self.all_archs:
                iter157.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.featureExpression is not None:
            oprot.writeFieldBegin('featureExpression', TType.STRING, 5)
            oprot.writeString(self.featureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.featureExpression)
            oprot.writeFieldEnd()
        if self.logical_connective is not None:
            oprot.writeFieldBegin('logical_connective', TType.STRING, 6)
            oprot.writeString(self.logical_connective.encode('utf-8') if sys.version_info[0] == 2 else self.logical_connective)
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 7)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 8)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 9)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesBinary_args)
getMarginalDrivingFeaturesBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
    (5, TType.STRING, 'featureExpression', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'logical_connective', 'UTF8', None, ),  # 6
    (7, TType.DOUBLE, 'supp', None, None, ),  # 7
    (8, TType.DOUBLE, 'conf', None, None, ),  # 8
    (9, TType.DOUBLE, 'lift', None, None, ),  # 9
)


class getMarginalDrivingFeaturesBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype161, _size158) = iprot.readListBegin()
                    for _i162 in range(_size158):
                        _elem163 = Feature()
                        _elem163.read(iprot)
                        self.success.append(_elem163)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter164 in self.success:
                iter164.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesBinary_result)
getMarginalDrivingFeaturesBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesEpsilonMOEABinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype168, _size165) = iprot.readListBegin()
                    for _i169 in range(_size165):
                        _elem170 = iprot.readI32()
                        self.behavioral.append(_elem170)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype174, _size171) = iprot.readListBegin()
                    for _i175 in range(_size171):
                        _elem176 = iprot.readI32()
                        self.non_behavioral.append(_elem176)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype180, _size177) = iprot.readListBegin()
                    for _i181 in range(_size177):
                        _elem182 = BinaryInputArchitecture()
                        _elem182.read(iprot)
                        self.all_archs.append(_elem182)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEABinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter183 in self.behavioral:
                oprot.writeI32(iter183)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter184 in self.non_behavioral:
                oprot.writeI32(iter184)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter185 in self.all_archs:
                iter185.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEABinary_args)
getDrivingFeaturesEpsilonMOEABinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
)


class getDrivingFeaturesEpsilonMOEABinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype189, _size186) = iprot.readListBegin()
                    for _i190 in range(_size186):
                        _elem191 = Feature()
                        _elem191.read(iprot)
                        self.success.append(_elem191)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEABinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter192 in self.success:
                iter192.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEABinary_result)
getDrivingFeaturesEpsilonMOEABinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesDiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype196, _size193) = iprot.readListBegin()
                    for _i197 in range(_size193):
                        _elem198 = iprot.readI32()
                        self.behavioral.append(_elem198)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype202, _size199) = iprot.readListBegin()
                    for _i203 in range(_size199):
                        _elem204 = iprot.readI32()
                        self.non_behavioral.append(_elem204)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype208, _size205) = iprot.readListBegin()
                    for _i209 in range(_size205):
                        _elem210 = DiscreteInputArchitecture()
                        _elem210.read(iprot)
                        self.all_archs.append(_elem210)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesDiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter211 in self.behavioral:
                oprot.writeI32(iter211)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter212 in self.non_behavioral:
                oprot.writeI32(iter212)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter213 in self.all_archs:
                iter213.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesDiscrete_args)
getDrivingFeaturesDiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class getDrivingFeaturesDiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype217, _size214) = iprot.readListBegin()
                    for _i218 in range(_size214):
                        _elem219 = Feature()
                        _elem219.read(iprot)
                        self.success.append(_elem219)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesDiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter220 in self.success:
                iter220.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesDiscrete_result)
getDrivingFeaturesDiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getMarginalDrivingFeaturesDiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - featureExpression
     - logical_connective
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, featureExpression=None, logical_connective=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.featureExpression = featureExpression
        self.logical_connective = logical_connective
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype224, _size221) = iprot.readListBegin()
                    for _i225 in range(_size221):
                        _elem226 = iprot.readI32()
                        self.behavioral.append(_elem226)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype230, _size227) = iprot.readListBegin()
                    for _i231 in range(_size227):
                        _elem232 = iprot.readI32()
                        self.non_behavioral.append(_elem232)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype236, _size233) = iprot.readListBegin()
                    for _i237 in range(_size233):
                        _elem238 = DiscreteInputArchitecture()
                        _elem238.read(iprot)
                        self.all_archs.append(_elem238)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.featureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.logical_connective = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesDiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter239 in self.behavioral:
                oprot.writeI32(iter239)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter240 in self.non_behavioral:
                oprot.writeI32(iter240)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter241 in self.all_archs:
                iter241.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.featureExpression is not None:
            oprot.writeFieldBegin('featureExpression', TType.STRING, 5)
            oprot.writeString(self.featureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.featureExpression)
            oprot.writeFieldEnd()
        if self.logical_connective is not None:
            oprot.writeFieldBegin('logical_connective', TType.STRING, 6)
            oprot.writeString(self.logical_connective.encode('utf-8') if sys.version_info[0] == 2 else self.logical_connective)
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 7)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 8)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 9)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesDiscrete_args)
getMarginalDrivingFeaturesDiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
    (5, TType.STRING, 'featureExpression', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'logical_connective', 'UTF8', None, ),  # 6
    (7, TType.DOUBLE, 'supp', None, None, ),  # 7
    (8, TType.DOUBLE, 'conf', None, None, ),  # 8
    (9, TType.DOUBLE, 'lift', None, None, ),  # 9
)


class getMarginalDrivingFeaturesDiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype245, _size242) = iprot.readListBegin()
                    for _i246 in range(_size242):
                        _elem247 = Feature()
                        _elem247.read(iprot)
                        self.success.append(_elem247)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesDiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter248 in self.success:
                iter248.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesDiscrete_result)
getMarginalDrivingFeaturesDiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesEpsilonMOEADiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype252, _size249) = iprot.readListBegin()
                    for _i253 in range(_size249):
                        _elem254 = iprot.readI32()
                        self.behavioral.append(_elem254)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype258, _size255) = iprot.readListBegin()
                    for _i259 in range(_size255):
                        _elem260 = iprot.readI32()
                        self.non_behavioral.append(_elem260)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype264, _size261) = iprot.readListBegin()
                    for _i265 in range(_size261):
                        _elem266 = DiscreteInputArchitecture()
                        _elem266.read(iprot)
                        self.all_archs.append(_elem266)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEADiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter267 in self.behavioral:
                oprot.writeI32(iter267)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter268 in self.non_behavioral:
                oprot.writeI32(iter268)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter269 in self.all_archs:
                iter269.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEADiscrete_args)
getDrivingFeaturesEpsilonMOEADiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
)


class getDrivingFeaturesEpsilonMOEADiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype273, _size270) = iprot.readListBegin()
                    for _i274 in range(_size270):
                        _elem275 = Feature()
                        _elem275.read(iprot)
                        self.success.append(_elem275)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEADiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter276 in self.success:
                iter276.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEADiscrete_result)
getDrivingFeaturesEpsilonMOEADiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesContinuous_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype280, _size277) = iprot.readListBegin()
                    for _i281 in range(_size277):
                        _elem282 = iprot.readI32()
                        self.behavioral.append(_elem282)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype286, _size283) = iprot.readListBegin()
                    for _i287 in range(_size283):
                        _elem288 = iprot.readI32()
                        self.non_behavioral.append(_elem288)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype292, _size289) = iprot.readListBegin()
                    for _i293 in range(_size289):
                        _elem294 = ContinuousInputArchitecture()
                        _elem294.read(iprot)
                        self.all_archs.append(_elem294)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesContinuous_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter295 in self.behavioral:
                oprot.writeI32(iter295)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter296 in self.non_behavioral:
                oprot.writeI32(iter296)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter297 in self.all_archs:
                iter297.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesContinuous_args)
getDrivingFeaturesContinuous_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [ContinuousInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class getDrivingFeaturesContinuous_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype301, _size298) = iprot.readListBegin()
                    for _i302 in range(_size298):
                        _elem303 = Feature()
                        _elem303.read(iprot)
                        self.success.append(_elem303)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesContinuous_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter304 in self.success:
                iter304.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesContinuous_result)
getDrivingFeaturesContinuous_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesEpsilonMOEAContinuous_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype308, _size305) = iprot.readListBegin()
                    for _i309 in range(_size305):
                        _elem310 = iprot.readI32()
                        self.behavioral.append(_elem310)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype314, _size311) = iprot.readListBegin()
                    for _i315 in range(_size311):
                        _elem316 = iprot.readI32()
                        self.non_behavioral.append(_elem316)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype320, _size317) = iprot.readListBegin()
                    for _i321 in range(_size317):
                        _elem322 = ContinuousInputArchitecture()
                        _elem322.read(iprot)
                        self.all_archs.append(_elem322)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEAContinuous_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter323 in self.behavioral:
                oprot.writeI32(iter323)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter324 in self.non_behavioral:
                oprot.writeI32(iter324)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter325 in self.all_archs:
                iter325.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEAContinuous_args)
getDrivingFeaturesEpsilonMOEAContinuous_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [ContinuousInputArchitecture, None], False), None, ),  # 4
)


class getDrivingFeaturesEpsilonMOEAContinuous_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype329, _size326) = iprot.readListBegin()
                    for _i330 in range(_size326):
                        _elem331 = Feature()
                        _elem331.read(iprot)
                        self.success.append(_elem331)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEAContinuous_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter332 in self.success:
                iter332.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEAContinuous_result)
getDrivingFeaturesEpsilonMOEAContinuous_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class generalizeFeatureBinary_args(object):
    """
    Attributes:
     - problem
     - session
     - behavioral
     - non_behavioral
     - all_archs
     - rootfeatureExpression
     - nodeFeatureExpression
    """


    def __init__(self, problem=None, session=None, behavioral=None, non_behavioral=None, all_archs=None, rootfeatureExpression=None, nodeFeatureExpression=None,):
        self.problem = problem
        self.session = session
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.rootfeatureExpression = rootfeatureExpression
        self.nodeFeatureExpression = nodeFeatureExpression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype336, _size333) = iprot.readListBegin()
                    for _i337 in range(_size333):
                        _elem338 = iprot.readI32()
                        self.behavioral.append(_elem338)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype342, _size339) = iprot.readListBegin()
                    for _i343 in range(_size339):
                        _elem344 = iprot.readI32()
                        self.non_behavioral.append(_elem344)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype348, _size345) = iprot.readListBegin()
                    for _i349 in range(_size345):
                        _elem350 = BinaryInputArchitecture()
                        _elem350.read(iprot)
                        self.all_archs.append(_elem350)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.rootfeatureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.nodeFeatureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('generalizeFeatureBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 2)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter351 in self.behavioral:
                oprot.writeI32(iter351)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter352 in self.non_behavioral:
                oprot.writeI32(iter352)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter353 in self.all_archs:
                iter353.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rootfeatureExpression is not None:
            oprot.writeFieldBegin('rootfeatureExpression', TType.STRING, 6)
            oprot.writeString(self.rootfeatureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.rootfeatureExpression)
            oprot.writeFieldEnd()
        if self.nodeFeatureExpression is not None:
            oprot.writeFieldBegin('nodeFeatureExpression', TType.STRING, 7)
            oprot.writeString(self.nodeFeatureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.nodeFeatureExpression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(generalizeFeatureBinary_args)
generalizeFeatureBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'session', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 5
    (6, TType.STRING, 'rootfeatureExpression', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'nodeFeatureExpression', 'UTF8', None, ),  # 7
)


class generalizeFeatureBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype357, _size354) = iprot.readListBegin()
                    for _i358 in range(_size354):
                        _elem359 = Feature()
                        _elem359.read(iprot)
                        self.success.append(_elem359)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('generalizeFeatureBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter360 in self.success:
                iter360.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(generalizeFeatureBinary_result)
generalizeFeatureBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesWithGeneralizationBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype364, _size361) = iprot.readListBegin()
                    for _i365 in range(_size361):
                        _elem366 = iprot.readI32()
                        self.behavioral.append(_elem366)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype370, _size367) = iprot.readListBegin()
                    for _i371 in range(_size367):
                        _elem372 = iprot.readI32()
                        self.non_behavioral.append(_elem372)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype376, _size373) = iprot.readListBegin()
                    for _i377 in range(_size373):
                        _elem378 = BinaryInputArchitecture()
                        _elem378.read(iprot)
                        self.all_archs.append(_elem378)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesWithGeneralizationBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter379 in self.behavioral:
                oprot.writeI32(iter379)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter380 in self.non_behavioral:
                oprot.writeI32(iter380)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter381 in self.all_archs:
                iter381.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesWithGeneralizationBinary_args)
getDrivingFeaturesWithGeneralizationBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
)


class getDrivingFeaturesWithGeneralizationBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype385, _size382) = iprot.readListBegin()
                    for _i386 in range(_size382):
                        _elem387 = Feature()
                        _elem387.read(iprot)
                        self.success.append(_elem387)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesWithGeneralizationBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter388 in self.success:
                iter388.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesWithGeneralizationBinary_result)
getDrivingFeaturesWithGeneralizationBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class simplifyFeatureExpression_args(object):
    """
    Attributes:
     - problem
     - expression
    """


    def __init__(self, problem=None, expression=None,):
        self.problem = problem
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simplifyFeatureExpression_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 2)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simplifyFeatureExpression_args)
simplifyFeatureExpression_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'expression', 'UTF8', None, ),  # 2
)


class simplifyFeatureExpression_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simplifyFeatureExpression_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simplifyFeatureExpression_result)
simplifyFeatureExpression_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class stopSearch_args(object):
    """
    Attributes:
     - session
    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopSearch_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopSearch_args)
stopSearch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class stopSearch_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopSearch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopSearch_result)
stopSearch_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class computeComplexityOfFeatures_args(object):
    """
    Attributes:
     - problem
     - expressions
    """


    def __init__(self, problem=None, expressions=None,):
        self.problem = problem
        self.expressions = expressions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.expressions = []
                    (_etype392, _size389) = iprot.readListBegin()
                    for _i393 in range(_size389):
                        _elem394 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.expressions.append(_elem394)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexityOfFeatures_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.expressions is not None:
            oprot.writeFieldBegin('expressions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.expressions))
            for iter395 in self.expressions:
                oprot.writeString(iter395.encode('utf-8') if sys.version_info[0] == 2 else iter395)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexityOfFeatures_args)
computeComplexityOfFeatures_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'expressions', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class computeComplexityOfFeatures_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype399, _size396) = iprot.readListBegin()
                    for _i400 in range(_size396):
                        _elem401 = iprot.readDouble()
                        self.success.append(_elem401)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexityOfFeatures_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter402 in self.success:
                oprot.writeDouble(iter402)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexityOfFeatures_result)
computeComplexityOfFeatures_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class computeAlgebraicTypicality_args(object):
    """
    Attributes:
     - problem
     - arch
     - feature
    """


    def __init__(self, problem=None, arch=None, feature=None,):
        self.problem = problem
        self.arch = arch
        self.feature = feature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.feature = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicality_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        if self.feature is not None:
            oprot.writeFieldBegin('feature', TType.STRING, 3)
            oprot.writeString(self.feature.encode('utf-8') if sys.version_info[0] == 2 else self.feature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicality_args)
computeAlgebraicTypicality_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
    (3, TType.STRING, 'feature', 'UTF8', None, ),  # 3
)


class computeAlgebraicTypicality_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype406, _size403) = iprot.readListBegin()
                    for _i407 in range(_size403):
                        _elem408 = iprot.readI32()
                        self.success.append(_elem408)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicality_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter409 in self.success:
                oprot.writeI32(iter409)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicality_result)
computeAlgebraicTypicality_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class computeComplexity_args(object):
    """
    Attributes:
     - problem
     - expression
    """


    def __init__(self, problem=None, expression=None,):
        self.problem = problem
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexity_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 2)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexity_args)
computeComplexity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'expression', 'UTF8', None, ),  # 2
)


class computeComplexity_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexity_result)
computeComplexity_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class convertToCNF_args(object):
    """
    Attributes:
     - expression
    """


    def __init__(self, expression=None,):
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToCNF_args')
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 1)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToCNF_args)
convertToCNF_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expression', 'UTF8', None, ),  # 1
)


class convertToCNF_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToCNF_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToCNF_result)
convertToCNF_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class convertToDNF_args(object):
    """
    Attributes:
     - expression
    """


    def __init__(self, expression=None,):
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToDNF_args')
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 1)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToDNF_args)
convertToDNF_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expression', 'UTF8', None, ),  # 1
)


class convertToDNF_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToDNF_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToDNF_result)
convertToDNF_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class setAssigningProblemEntities_args(object):
    """
    Attributes:
     - problem
     - entities
    """


    def __init__(self, problem=None, entities=None,):
        self.problem = problem
        self.entities = entities

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.entities = AssigningProblemEntities()
                    self.entities.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAssigningProblemEntities_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.entities is not None:
            oprot.writeFieldBegin('entities', TType.STRUCT, 2)
            self.entities.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAssigningProblemEntities_args)
setAssigningProblemEntities_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'entities', [AssigningProblemEntities, None], None, ),  # 2
)


class setAssigningProblemEntities_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAssigningProblemEntities_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAssigningProblemEntities_result)
setAssigningProblemEntities_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class setAssigningProblemGeneralizedConcepts_args(object):
    """
    Attributes:
     - problem
     - generalizedConcepts
    """


    def __init__(self, problem=None, generalizedConcepts=None,):
        self.problem = problem
        self.generalizedConcepts = generalizedConcepts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.generalizedConcepts = AssigningProblemEntities()
                    self.generalizedConcepts.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAssigningProblemGeneralizedConcepts_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.generalizedConcepts is not None:
            oprot.writeFieldBegin('generalizedConcepts', TType.STRUCT, 2)
            self.generalizedConcepts.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAssigningProblemGeneralizedConcepts_args)
setAssigningProblemGeneralizedConcepts_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'generalizedConcepts', [AssigningProblemEntities, None], None, ),  # 2
)


class setAssigningProblemGeneralizedConcepts_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAssigningProblemGeneralizedConcepts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAssigningProblemGeneralizedConcepts_result)
setAssigningProblemGeneralizedConcepts_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class getAssigningProblemEntities_args(object):
    """
    Attributes:
     - problem
    """


    def __init__(self, problem=None,):
        self.problem = problem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAssigningProblemEntities_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAssigningProblemEntities_args)
getAssigningProblemEntities_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
)


class getAssigningProblemEntities_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AssigningProblemEntities()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAssigningProblemEntities_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAssigningProblemEntities_result)
getAssigningProblemEntities_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [AssigningProblemEntities, None], None, ),  # 0
)


class getAssigningProblemConceptHierarchy_args(object):
    """
    Attributes:
     - problem
     - params
    """


    def __init__(self, problem=None, params=None,):
        self.problem = problem
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.params = AssigningProblemEntities()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAssigningProblemConceptHierarchy_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 2)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAssigningProblemConceptHierarchy_args)
getAssigningProblemConceptHierarchy_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'params', [AssigningProblemEntities, None], None, ),  # 2
)


class getAssigningProblemConceptHierarchy_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FlattenedConceptHierarchy()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAssigningProblemConceptHierarchy_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAssigningProblemConceptHierarchy_result)
getAssigningProblemConceptHierarchy_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FlattenedConceptHierarchy, None], None, ),  # 0
)


class computeAlgebraicTypicalityWithStringInput_args(object):
    """
    Attributes:
     - problem
     - architecture
     - feature
    """


    def __init__(self, problem=None, architecture=None, feature=None,):
        self.problem = problem
        self.architecture = architecture
        self.feature = feature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.architecture = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.feature = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicalityWithStringInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.architecture is not None:
            oprot.writeFieldBegin('architecture', TType.STRING, 2)
            oprot.writeString(self.architecture.encode('utf-8') if sys.version_info[0] == 2 else self.architecture)
            oprot.writeFieldEnd()
        if self.feature is not None:
            oprot.writeFieldBegin('feature', TType.STRING, 3)
            oprot.writeString(self.feature.encode('utf-8') if sys.version_info[0] == 2 else self.feature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicalityWithStringInput_args)
computeAlgebraicTypicalityWithStringInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'architecture', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'feature', 'UTF8', None, ),  # 3
)


class computeAlgebraicTypicalityWithStringInput_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype413, _size410) = iprot.readListBegin()
                    for _i414 in range(_size410):
                        _elem415 = iprot.readI32()
                        self.success.append(_elem415)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicalityWithStringInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter416 in self.success:
                oprot.writeI32(iter416)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicalityWithStringInput_result)
computeAlgebraicTypicalityWithStringInput_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)
fix_spec(all_structs)
del all_structs

